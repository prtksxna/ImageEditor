{"version":3,"sources":["oojs.jquery.js"],"names":["global","simpleArrayCombine","a","b","includeB","i","ilen","isInB","bObj","result","length","push","oo","hasOwn","hasOwnProperty","createObject","toString","Object","create","Empty","prototype","properties","obj","call","constructor","value","initClass","fn","inheritClass","targetFn","originFn","targetConstructor","Error","parent","enumerable","writable","configurable","mixinClass","key","getProp","retval","arguments","undefined","setProp","prop","cloneObject","origin","r","getObjectValues","values","TypeError","binarySearch","arr","searchFunc","forInsertion","mid","cmpResult","left","right","compare","asymmetrical","aValue","bValue","aType","bType","k","nodeType","isEqualNode","copy","source","leafCallback","nodeCallback","destination","Array","isArray","clone","cloneNode","isPlainObject","getHash","val","JSON","stringify","keySortReplacer","normalized","keys","len","getHashObject","sort","unique","reduce","current","indexOf","simpleArrayUnion","j","jlen","simpleArrayIntersection","simpleArrayDifference","$","validateMethod","method","context","EventEmitter","this","bindings","on","event","args","once","listener","eventEmitter","wrapper","off","apply","splice","emit","binding","slice","concat","connect","methods","disconnect","normalizeArrayIndex","index","EmitterList","items","aggregateItemEvents","getItems","getItemIndex","item","getItemCount","isEmpty","aggregate","events","add","remove","itemEvent","groupEvent","addItems","oldIndex","moveItem","insertItem","newIndex","existingIndex","removeItems","clearItems","cleared","SortedEmitterList","sortingCallback","sortChange","itemSortChange","onItemSortChange","setSortingCallback","insertionIndex","findInsertionIndex","list","otherItem","Registry","registry","register","name","data","unregister","lookup","Factory","module","exports","OO"],"mappings":"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","file":"oojs.jquery.min.js","sourcesContent":["/*!\n * OOjs v1.1.10 optimised for jQuery\n * https://www.mediawiki.org/wiki/OOjs\n *\n * Copyright 2011-2015 OOjs Team and other contributors.\n * Released under the MIT license\n * http://oojs.mit-license.org\n *\n * Date: 2015-11-11T16:49:11Z\n */\n( function ( global ) {\n\n'use strict';\n\n/*exported toString */\nvar\n\t/**\n\t * Namespace for all classes, static methods and static properties.\n\t * @class OO\n\t * @singleton\n\t */\n\too = {},\n\t// Optimisation: Local reference to Object.prototype.hasOwnProperty\n\thasOwn = oo.hasOwnProperty,\n\ttoString = oo.toString,\n\t// Object.create() is impossible to fully polyfill, so don't require it\n\tcreateObject = Object.create || ( function () {\n\t\t// Reusable constructor function\n\t\tfunction Empty() {}\n\t\treturn function ( prototype, properties ) {\n\t\t\tvar obj;\n\t\t\tEmpty.prototype = prototype;\n\t\t\tobj = new Empty();\n\t\t\tif ( properties && hasOwn.call( properties, 'constructor' ) ) {\n\t\t\t\tobj.constructor = properties.constructor.value;\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\t} )();\n\n/* Class Methods */\n\n/**\n * Utility to initialize a class for OO inheritance.\n *\n * Currently this just initializes an empty static object.\n *\n * @param {Function} fn\n */\noo.initClass = function ( fn ) {\n\tfn.static = fn.static || {};\n};\n\n/**\n * Inherit from prototype to another using Object#create.\n *\n * Beware: This redefines the prototype, call before setting your prototypes.\n *\n * Beware: This redefines the prototype, can only be called once on a function.\n * If called multiple times on the same function, the previous prototype is lost.\n * This is how prototypal inheritance works, it can only be one straight chain\n * (just like classical inheritance in PHP for example). If you need to work with\n * multiple constructors consider storing an instance of the other constructor in a\n * property instead, or perhaps use a mixin (see OO.mixinClass).\n *\n *     function Thing() {}\n *     Thing.prototype.exists = function () {};\n *\n *     function Person() {\n *         Person.super.apply( this, arguments );\n *     }\n *     OO.inheritClass( Person, Thing );\n *     Person.static.defaultEyeCount = 2;\n *     Person.prototype.walk = function () {};\n *\n *     function Jumper() {\n *         Jumper.super.apply( this, arguments );\n *     }\n *     OO.inheritClass( Jumper, Person );\n *     Jumper.prototype.jump = function () {};\n *\n *     Jumper.static.defaultEyeCount === 2;\n *     var x = new Jumper();\n *     x.jump();\n *     x.walk();\n *     x instanceof Thing && x instanceof Person && x instanceof Jumper;\n *\n * @param {Function} targetFn\n * @param {Function} originFn\n * @throws {Error} If target already inherits from origin\n */\noo.inheritClass = function ( targetFn, originFn ) {\n\tvar targetConstructor;\n\n\tif ( targetFn.prototype instanceof originFn ) {\n\t\tthrow new Error( 'Target already inherits from origin' );\n\t}\n\n\ttargetConstructor = targetFn.prototype.constructor;\n\n\t// Using ['super'] instead of .super because 'super' is not supported\n\t// by IE 8 and below (bug 63303).\n\t// Provide .parent as alias for code supporting older browsers which\n\t// allows people to comply with their style guide.\n\ttargetFn[ 'super' ] = targetFn.parent = originFn;\n\n\ttargetFn.prototype = createObject( originFn.prototype, {\n\t\t// Restore constructor property of targetFn\n\t\tconstructor: {\n\t\t\tvalue: targetConstructor,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t}\n\t} );\n\n\t// Extend static properties - always initialize both sides\n\too.initClass( originFn );\n\ttargetFn.static = createObject( originFn.static );\n};\n\n/**\n * Copy over *own* prototype properties of a mixin.\n *\n * The 'constructor' (whether implicit or explicit) is not copied over.\n *\n * This does not create inheritance to the origin. If you need inheritance,\n * use OO.inheritClass instead.\n *\n * Beware: This can redefine a prototype property, call before setting your prototypes.\n *\n * Beware: Don't call before OO.inheritClass.\n *\n *     function Foo() {}\n *     function Context() {}\n *\n *     // Avoid repeating this code\n *     function ContextLazyLoad() {}\n *     ContextLazyLoad.prototype.getContext = function () {\n *         if ( !this.context ) {\n *             this.context = new Context();\n *         }\n *         return this.context;\n *     };\n *\n *     function FooBar() {}\n *     OO.inheritClass( FooBar, Foo );\n *     OO.mixinClass( FooBar, ContextLazyLoad );\n *\n * @param {Function} targetFn\n * @param {Function} originFn\n */\noo.mixinClass = function ( targetFn, originFn ) {\n\tvar key;\n\n\t// Copy prototype properties\n\tfor ( key in originFn.prototype ) {\n\t\tif ( key !== 'constructor' && hasOwn.call( originFn.prototype, key ) ) {\n\t\t\ttargetFn.prototype[ key ] = originFn.prototype[ key ];\n\t\t}\n\t}\n\n\t// Copy static properties - always initialize both sides\n\too.initClass( targetFn );\n\tif ( originFn.static ) {\n\t\tfor ( key in originFn.static ) {\n\t\t\tif ( hasOwn.call( originFn.static, key ) ) {\n\t\t\t\ttargetFn.static[ key ] = originFn.static[ key ];\n\t\t\t}\n\t\t}\n\t} else {\n\t\too.initClass( originFn );\n\t}\n};\n\n/* Object Methods */\n\n/**\n * Get a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors.\n *\n * `quux = oo.getProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `quux = obj.foo.bar.baz;`\n * except that the former protects against JS errors if one of the intermediate properties\n * is undefined. Instead of throwing an error, this function will return undefined in\n * that case.\n *\n * @param {Object} obj\n * @param {...Mixed} [keys]\n * @return {Object|undefined} obj[arguments[1]][arguments[2]].... or undefined\n */\noo.getProp = function ( obj ) {\n\tvar i,\n\t\tretval = obj;\n\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\tif ( retval === undefined || retval === null ) {\n\t\t\t// Trying to access a property of undefined or null causes an error\n\t\t\treturn undefined;\n\t\t}\n\t\tretval = retval[ arguments[ i ] ];\n\t}\n\treturn retval;\n};\n\n/**\n * Set a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors.\n *\n * `oo.setProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `obj.foo.bar = baz;` except that\n * the former protects against JS errors if one of the intermediate properties is\n * undefined. Instead of throwing an error, undefined intermediate properties will be\n * initialized to an empty object. If an intermediate property is not an object, or if obj itself\n * is not an object, this function will silently abort.\n *\n * @param {Object} obj\n * @param {...Mixed} [keys]\n * @param {Mixed} [value]\n */\noo.setProp = function ( obj ) {\n\tvar i,\n\t\tprop = obj;\n\tif ( Object( obj ) !== obj ) {\n\t\treturn;\n\t}\n\tfor ( i = 1; i < arguments.length - 2; i++ ) {\n\t\tif ( prop[ arguments[ i ] ] === undefined ) {\n\t\t\tprop[ arguments[ i ] ] = {};\n\t\t}\n\t\tif ( Object( prop[ arguments[ i ] ] ) !== prop[ arguments[ i ] ] ) {\n\t\t\treturn;\n\t\t}\n\t\tprop = prop[ arguments[ i ] ];\n\t}\n\tprop[ arguments[ arguments.length - 2 ] ] = arguments[ arguments.length - 1 ];\n};\n\n/**\n * Create a new object that is an instance of the same\n * constructor as the input, inherits from the same object\n * and contains the same own properties.\n *\n * This makes a shallow non-recursive copy of own properties.\n * To create a recursive copy of plain objects, use #copy.\n *\n *     var foo = new Person( mom, dad );\n *     foo.setAge( 21 );\n *     var foo2 = OO.cloneObject( foo );\n *     foo.setAge( 22 );\n *\n *     // Then\n *     foo2 !== foo; // true\n *     foo2 instanceof Person; // true\n *     foo2.getAge(); // 21\n *     foo.getAge(); // 22\n *\n * @param {Object} origin\n * @return {Object} Clone of origin\n */\noo.cloneObject = function ( origin ) {\n\tvar key, r;\n\n\tr = createObject( origin.constructor.prototype );\n\n\tfor ( key in origin ) {\n\t\tif ( hasOwn.call( origin, key ) ) {\n\t\t\tr[ key ] = origin[ key ];\n\t\t}\n\t}\n\n\treturn r;\n};\n\n/**\n * Get an array of all property values in an object.\n *\n * @param {Object} obj Object to get values from\n * @return {Array} List of object values\n */\noo.getObjectValues = function ( obj ) {\n\tvar key, values;\n\n\tif ( obj !== Object( obj ) ) {\n\t\tthrow new TypeError( 'Called on non-object' );\n\t}\n\n\tvalues = [];\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tvalues[ values.length ] = obj[ key ];\n\t\t}\n\t}\n\n\treturn values;\n};\n\n/**\n * Use binary search to locate an element in a sorted array.\n *\n * searchFunc is given an element from the array. `searchFunc(elem)` must return a number\n * above 0 if the element we're searching for is to the right of (has a higher index than) elem,\n * below 0 if it is to the left of elem, or zero if it's equal to elem.\n *\n * To search for a specific value with a comparator function (a `function cmp(a,b)` that returns\n * above 0 if `a > b`, below 0 if `a < b`, and 0 if `a == b`), you can use\n * `searchFunc = cmp.bind( null, value )`.\n *\n * @param {Array} arr Array to search in\n * @param {Function} searchFunc Search function\n * @param {boolean} [forInsertion] If not found, return index where val could be inserted\n * @return {number|null} Index where val was found, or null if not found\n */\noo.binarySearch = function ( arr, searchFunc, forInsertion ) {\n\tvar mid, cmpResult,\n\t\tleft = 0,\n\t\tright = arr.length;\n\twhile ( left < right ) {\n\t\t// Equivalent to Math.floor( ( left + right ) / 2 ) but much faster\n\t\t/*jshint bitwise:false */\n\t\tmid = ( left + right ) >> 1;\n\t\tcmpResult = searchFunc( arr[ mid ] );\n\t\tif ( cmpResult < 0 ) {\n\t\t\tright = mid;\n\t\t} else if ( cmpResult > 0 ) {\n\t\t\tleft = mid + 1;\n\t\t} else {\n\t\t\treturn mid;\n\t\t}\n\t}\n\treturn forInsertion ? right : null;\n};\n\n/**\n * Recursively compare properties between two objects.\n *\n * A false result may be caused by property inequality or by properties in one object missing from\n * the other. An asymmetrical test may also be performed, which checks only that properties in the\n * first object are present in the second object, but not the inverse.\n *\n * If either a or b is null or undefined it will be treated as an empty object.\n *\n * @param {Object|undefined|null} a First object to compare\n * @param {Object|undefined|null} b Second object to compare\n * @param {boolean} [asymmetrical] Whether to check only that a's values are equal to b's\n *  (i.e. a is a subset of b)\n * @return {boolean} If the objects contain the same values as each other\n */\noo.compare = function ( a, b, asymmetrical ) {\n\tvar aValue, bValue, aType, bType, k;\n\n\tif ( a === b ) {\n\t\treturn true;\n\t}\n\n\ta = a || {};\n\tb = b || {};\n\n\tif ( typeof a.nodeType === 'number' && typeof a.isEqualNode === 'function' ) {\n\t\treturn a.isEqualNode( b );\n\t}\n\n\tfor ( k in a ) {\n\t\tif ( !hasOwn.call( a, k ) || a[ k ] === undefined || a[ k ] === b[ k ] ) {\n\t\t\t// Support es3-shim: Without the hasOwn filter, comparing [] to {} will be false in ES3\n\t\t\t// because the shimmed \"forEach\" is enumerable and shows up in Array but not Object.\n\t\t\t// Also ignore undefined values, because there is no conceptual difference between\n\t\t\t// a key that is absent and a key that is present but whose value is undefined.\n\t\t\tcontinue;\n\t\t}\n\n\t\taValue = a[ k ];\n\t\tbValue = b[ k ];\n\t\taType = typeof aValue;\n\t\tbType = typeof bValue;\n\t\tif ( aType !== bType ||\n\t\t\t(\n\t\t\t\t( aType === 'string' || aType === 'number' || aType === 'boolean' ) &&\n\t\t\t\taValue !== bValue\n\t\t\t) ||\n\t\t\t( aValue === Object( aValue ) && !oo.compare( aValue, bValue, true ) ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// If the check is not asymmetrical, recursing with the arguments swapped will verify our result\n\treturn asymmetrical ? true : oo.compare( b, a, true );\n};\n\n/**\n * Create a plain deep copy of any kind of object.\n *\n * Copies are deep, and will either be an object or an array depending on `source`.\n *\n * @param {Object} source Object to copy\n * @param {Function} [leafCallback] Applied to leaf values after they are cloned but before they are added to the clone\n * @param {Function} [nodeCallback] Applied to all values before they are cloned.  If the nodeCallback returns a value other than undefined, the returned value is used instead of attempting to clone.\n * @return {Object} Copy of source object\n */\noo.copy = function ( source, leafCallback, nodeCallback ) {\n\tvar key, destination;\n\n\tif ( nodeCallback ) {\n\t\t// Extensibility: check before attempting to clone source.\n\t\tdestination = nodeCallback( source );\n\t\tif ( destination !== undefined ) {\n\t\t\treturn destination;\n\t\t}\n\t}\n\n\tif ( Array.isArray( source ) ) {\n\t\t// Array (fall through)\n\t\tdestination = new Array( source.length );\n\t} else if ( source && typeof source.clone === 'function' ) {\n\t\t// Duck type object with custom clone method\n\t\treturn leafCallback ? leafCallback( source.clone() ) : source.clone();\n\t} else if ( source && typeof source.cloneNode === 'function' ) {\n\t\t// DOM Node\n\t\treturn leafCallback ?\n\t\t\tleafCallback( source.cloneNode( true ) ) :\n\t\t\tsource.cloneNode( true );\n\t} else if ( oo.isPlainObject( source ) ) {\n\t\t// Plain objects (fall through)\n\t\tdestination = {};\n\t} else {\n\t\t// Non-plain objects (incl. functions) and primitive values\n\t\treturn leafCallback ? leafCallback( source ) : source;\n\t}\n\n\t// source is an array or a plain object\n\tfor ( key in source ) {\n\t\tdestination[ key ] = oo.copy( source[ key ], leafCallback, nodeCallback );\n\t}\n\n\t// This is an internal node, so we don't apply the leafCallback.\n\treturn destination;\n};\n\n/**\n * Generate a hash of an object based on its name and data.\n *\n * Performance optimization: <http://jsperf.com/ve-gethash-201208#/toJson_fnReplacerIfAoForElse>\n *\n * To avoid two objects with the same values generating different hashes, we utilize the replacer\n * argument of JSON.stringify and sort the object by key as it's being serialized. This may or may\n * not be the fastest way to do this; we should investigate this further.\n *\n * Objects and arrays are hashed recursively. When hashing an object that has a .getHash()\n * function, we call that function and use its return value rather than hashing the object\n * ourselves. This allows classes to define custom hashing.\n *\n * @param {Object} val Object to generate hash for\n * @return {string} Hash of object\n */\noo.getHash = function ( val ) {\n\treturn JSON.stringify( val, oo.getHash.keySortReplacer );\n};\n\n/**\n * Sort objects by key (helper function for OO.getHash).\n *\n * This is a callback passed into JSON.stringify.\n *\n * @method getHash_keySortReplacer\n * @param {string} key Property name of value being replaced\n * @param {Mixed} val Property value to replace\n * @return {Mixed} Replacement value\n */\noo.getHash.keySortReplacer = function ( key, val ) {\n\tvar normalized, keys, i, len;\n\tif ( val && typeof val.getHashObject === 'function' ) {\n\t\t// This object has its own custom hash function, use it\n\t\tval = val.getHashObject();\n\t}\n\tif ( !Array.isArray( val ) && Object( val ) === val ) {\n\t\t// Only normalize objects when the key-order is ambiguous\n\t\t// (e.g. any object not an array).\n\t\tnormalized = {};\n\t\tkeys = Object.keys( val ).sort();\n\t\ti = 0;\n\t\tlen = keys.length;\n\t\tfor ( ; i < len; i += 1 ) {\n\t\t\tnormalized[ keys[ i ] ] = val[ keys[ i ] ];\n\t\t}\n\t\treturn normalized;\n\n\t// Primitive values and arrays get stable hashes\n\t// by default. Lets those be stringified as-is.\n\t} else {\n\t\treturn val;\n\t}\n};\n\n/**\n * Get the unique values of an array, removing duplicates\n *\n * @param {Array} arr Array\n * @return {Array} Unique values in array\n */\noo.unique = function ( arr ) {\n\treturn arr.reduce( function ( result, current ) {\n\t\tif ( result.indexOf( current ) === -1 ) {\n\t\t\tresult.push( current );\n\t\t}\n\t\treturn result;\n\t}, [] );\n};\n\n/**\n * Compute the union (duplicate-free merge) of a set of arrays.\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * By building an object (with the values for keys) in parallel with\n * the array, a new item's existence in the union can be computed faster.\n *\n * @param {...Array} arrays Arrays to union\n * @return {Array} Union of the arrays\n */\noo.simpleArrayUnion = function () {\n\tvar i, ilen, arr, j, jlen,\n\t\tobj = {},\n\t\tresult = [];\n\n\tfor ( i = 0, ilen = arguments.length; i < ilen; i++ ) {\n\t\tarr = arguments[ i ];\n\t\tfor ( j = 0, jlen = arr.length; j < jlen; j++ ) {\n\t\t\tif ( !obj[ arr[ j ] ] ) {\n\t\t\t\tobj[ arr[ j ] ] = true;\n\t\t\t\tresult.push( arr[ j ] );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Combine arrays (intersection or difference).\n *\n * An intersection checks the item exists in 'b' while difference checks it doesn't.\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * By building an object (with the values for keys) of 'b' we can\n * compute the result faster.\n *\n * @private\n * @param {Array} a First array\n * @param {Array} b Second array\n * @param {boolean} includeB Whether to items in 'b'\n * @return {Array} Combination (intersection or difference) of arrays\n */\nfunction simpleArrayCombine( a, b, includeB ) {\n\tvar i, ilen, isInB,\n\t\tbObj = {},\n\t\tresult = [];\n\n\tfor ( i = 0, ilen = b.length; i < ilen; i++ ) {\n\t\tbObj[ b[ i ] ] = true;\n\t}\n\n\tfor ( i = 0, ilen = a.length; i < ilen; i++ ) {\n\t\tisInB = !!bObj[ a[ i ] ];\n\t\tif ( isInB === includeB ) {\n\t\t\tresult.push( a[ i ] );\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute the intersection of two arrays (items in both arrays).\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * @param {Array} a First array\n * @param {Array} b Second array\n * @return {Array} Intersection of arrays\n */\noo.simpleArrayIntersection = function ( a, b ) {\n\treturn simpleArrayCombine( a, b, true );\n};\n\n/**\n * Compute the difference of two arrays (items in 'a' but not 'b').\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * @param {Array} a First array\n * @param {Array} b Second array\n * @return {Array} Intersection of arrays\n */\noo.simpleArrayDifference = function ( a, b ) {\n\treturn simpleArrayCombine( a, b, false );\n};\n\n/*global $ */\n\noo.isPlainObject = $.isPlainObject;\n\n/*global hasOwn */\n\n( function () {\n\n\t/**\n\t * @class OO.EventEmitter\n\t *\n\t * @constructor\n\t */\n\too.EventEmitter = function OoEventEmitter() {\n\t\t// Properties\n\n\t\t/**\n\t\t * Storage of bound event handlers by event name.\n\t\t *\n\t\t * @property\n\t\t */\n\t\tthis.bindings = {};\n\t};\n\n\too.initClass( oo.EventEmitter );\n\n\t/* Private helper functions */\n\n\t/**\n\t * Validate a function or method call in a context\n\t *\n\t * For a method name, check that it names a function in the context object\n\t *\n\t * @private\n\t * @param {Function|string} method Function or method name\n\t * @param {Mixed} context The context of the call\n\t * @throws {Error} A method name is given but there is no context\n\t * @throws {Error} In the context object, no property exists with the given name\n\t * @throws {Error} In the context object, the named property is not a function\n\t */\n\tfunction validateMethod( method, context ) {\n\t\t// Validate method and context\n\t\tif ( typeof method === 'string' ) {\n\t\t\t// Validate method\n\t\t\tif ( context === undefined || context === null ) {\n\t\t\t\tthrow new Error( 'Method name \"' + method + '\" has no context.' );\n\t\t\t}\n\t\t\tif ( typeof context[ method ] !== 'function' ) {\n\t\t\t\t// Technically the property could be replaced by a function before\n\t\t\t\t// call time. But this probably signals a typo.\n\t\t\t\tthrow new Error( 'Property \"' + method + '\" is not a function' );\n\t\t\t}\n\t\t} else if ( typeof method !== 'function' ) {\n\t\t\tthrow new Error( 'Invalid callback. Function or method name expected.' );\n\t\t}\n\t}\n\n\t/* Methods */\n\n\t/**\n\t * Add a listener to events of a specific event.\n\t *\n\t * The listener can be a function or the string name of a method; if the latter, then the\n\t * name lookup happens at the time the listener is called.\n\t *\n\t * @param {string} event Type of event to listen to\n\t * @param {Function|string} method Function or method name to call when event occurs\n\t * @param {Array} [args] Arguments to pass to listener, will be prepended to emitted arguments\n\t * @param {Object} [context=null] Context object for function or method call\n\t * @throws {Error} Listener argument is not a function or a valid method name\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.on = function ( event, method, args, context ) {\n\t\tvar bindings;\n\n\t\tvalidateMethod( method, context );\n\n\t\tif ( hasOwn.call( this.bindings, event ) ) {\n\t\t\tbindings = this.bindings[ event ];\n\t\t} else {\n\t\t\t// Auto-initialize bindings list\n\t\t\tbindings = this.bindings[ event ] = [];\n\t\t}\n\t\t// Add binding\n\t\tbindings.push( {\n\t\t\tmethod: method,\n\t\t\targs: args,\n\t\t\tcontext: ( arguments.length < 4 ) ? null : context\n\t\t} );\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a one-time listener to a specific event.\n\t *\n\t * @param {string} event Type of event to listen to\n\t * @param {Function} listener Listener to call when event occurs\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.once = function ( event, listener ) {\n\t\tvar eventEmitter = this,\n\t\t\twrapper = function () {\n\t\t\t\teventEmitter.off( event, wrapper );\n\t\t\t\treturn listener.apply( this, arguments );\n\t\t\t};\n\t\treturn this.on( event, wrapper );\n\t};\n\n\t/**\n\t * Remove a specific listener from a specific event.\n\t *\n\t * @param {string} event Type of event to remove listener from\n\t * @param {Function|string} [method] Listener to remove. Must be in the same form as was passed\n\t * to \"on\". Omit to remove all listeners.\n\t * @param {Object} [context=null] Context object function or method call\n\t * @chainable\n\t * @throws {Error} Listener argument is not a function or a valid method name\n\t */\n\too.EventEmitter.prototype.off = function ( event, method, context ) {\n\t\tvar i, bindings;\n\n\t\tif ( arguments.length === 1 ) {\n\t\t\t// Remove all bindings for event\n\t\t\tdelete this.bindings[ event ];\n\t\t\treturn this;\n\t\t}\n\n\t\tvalidateMethod( method, context );\n\n\t\tif ( !hasOwn.call( this.bindings, event ) || !this.bindings[ event ].length ) {\n\t\t\t// No matching bindings\n\t\t\treturn this;\n\t\t}\n\n\t\t// Default to null context\n\t\tif ( arguments.length < 3 ) {\n\t\t\tcontext = null;\n\t\t}\n\n\t\t// Remove matching handlers\n\t\tbindings = this.bindings[ event ];\n\t\ti = bindings.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( bindings[ i ].method === method && bindings[ i ].context === context ) {\n\t\t\t\tbindings.splice( i, 1 );\n\t\t\t}\n\t\t}\n\n\t\t// Cleanup if now empty\n\t\tif ( bindings.length === 0 ) {\n\t\t\tdelete this.bindings[ event ];\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Emit an event.\n\t *\n\t * @param {string} event Type of event\n\t * @param {...Mixed} args First in a list of variadic arguments passed to event handler (optional)\n\t * @return {boolean} Whether the event was handled by at least one listener\n\t */\n\too.EventEmitter.prototype.emit = function ( event ) {\n\t\tvar args = [],\n\t\t\ti, len, binding, bindings, method;\n\n\t\tif ( hasOwn.call( this.bindings, event ) ) {\n\t\t\t// Slicing ensures that we don't get tripped up by event handlers that add/remove bindings\n\t\t\tbindings = this.bindings[ event ].slice();\n\t\t\tfor ( i = 1, len = arguments.length; i < len; i++ ) {\n\t\t\t\targs.push( arguments[ i ] );\n\t\t\t}\n\t\t\tfor ( i = 0, len = bindings.length; i < len; i++ ) {\n\t\t\t\tbinding = bindings[ i ];\n\t\t\t\tif ( typeof binding.method === 'string' ) {\n\t\t\t\t\t// Lookup method by name (late binding)\n\t\t\t\t\tmethod = binding.context[ binding.method ];\n\t\t\t\t} else {\n\t\t\t\t\tmethod = binding.method;\n\t\t\t\t}\n\t\t\t\tmethod.apply(\n\t\t\t\t\tbinding.context,\n\t\t\t\t\tbinding.args ? binding.args.concat( args ) : args\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Connect event handlers to an object.\n\t *\n\t * @param {Object} context Object to call methods on when events occur\n\t * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} methods List of\n\t *  event bindings keyed by event name containing either method names, functions or arrays containing\n\t *  method name or function followed by a list of arguments to be passed to callback before emitted\n\t *  arguments\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.connect = function ( context, methods ) {\n\t\tvar method, args, event;\n\n\t\tfor ( event in methods ) {\n\t\t\tmethod = methods[ event ];\n\t\t\t// Allow providing additional args\n\t\t\tif ( Array.isArray( method ) ) {\n\t\t\t\targs = method.slice( 1 );\n\t\t\t\tmethod = method[ 0 ];\n\t\t\t} else {\n\t\t\t\targs = [];\n\t\t\t}\n\t\t\t// Add binding\n\t\t\tthis.on( event, method, args, context );\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Disconnect event handlers from an object.\n\t *\n\t * @param {Object} context Object to disconnect methods from\n\t * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} [methods] List of\n\t * event bindings keyed by event name. Values can be either method names or functions, but must be\n\t * consistent with those used in the corresponding call to \"connect\".\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.disconnect = function ( context, methods ) {\n\t\tvar i, event, method, bindings;\n\n\t\tif ( methods ) {\n\t\t\t// Remove specific connections to the context\n\t\t\tfor ( event in methods ) {\n\t\t\t\tmethod = methods[ event ];\n\t\t\t\tif ( Array.isArray( method ) ) {\n\t\t\t\t\tmethod = method[ 0 ];\n\t\t\t\t}\n\t\t\t\tthis.off( event, method, context );\n\t\t\t}\n\t\t} else {\n\t\t\t// Remove all connections to the context\n\t\t\tfor ( event in this.bindings ) {\n\t\t\t\tbindings = this.bindings[ event ];\n\t\t\t\ti = bindings.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t// bindings[i] may have been removed by the previous step's\n\t\t\t\t\t// this.off so check it still exists\n\t\t\t\t\tif ( bindings[ i ] && bindings[ i ].context === context ) {\n\t\t\t\t\t\tthis.off( event, bindings[ i ].method, context );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n}() );\n\n( function () {\n\n\t/**\n\t * Contain and manage a list of OO.EventEmitter items.\n\t *\n\t * Aggregates and manages their events collectively.\n\t *\n\t * This mixin must be used in a class that also mixes in OO.EventEmitter.\n\t *\n\t * @abstract\n\t * @class OO.EmitterList\n\t * @constructor\n\t */\n\too.EmitterList = function OoEmitterList() {\n\t\tthis.items = [];\n\t\tthis.aggregateItemEvents = {};\n\t};\n\n\t/* Events */\n\n\t/**\n\t * Item has been added\n\t *\n\t * @event add\n\t * @param {OO.EventEmitter} item Added item\n\t * @param {number} index Index items were added at\n\t */\n\n\t/**\n\t * Item has been moved to a new index\n\t *\n\t * @event move\n\t * @param {OO.EventEmitter} item Moved item\n\t * @param {number} index Index item was moved to\n\t * @param {number} oldIndex The original index the item was in\n\t */\n\n\t/**\n\t * Item has been removed\n\t *\n\t * @event remove\n\t * @param {OO.EventEmitter} item Removed item\n\t * @param {number} index Index the item was removed from\n\t */\n\n\t/**\n\t * @event clear The list has been cleared of items\n\t */\n\n\t/* Methods */\n\n\t/**\n\t * Normalize requested index to fit into the bounds of the given array.\n\t *\n\t * @private\n\t * @static\n\t * @param {Array} arr Given array\n\t * @param {number|undefined} index Requested index\n\t * @return {number} Normalized index\n\t */\n\tfunction normalizeArrayIndex( arr, index ) {\n\t\treturn ( index === undefined || index < 0 || index >= arr.length ) ?\n\t\t\tarr.length :\n\t\t\tindex;\n\t}\n\n\t/**\n\t * Get all items.\n\t *\n\t * @return {OO.EventEmitter[]} Items in the list\n\t */\n\too.EmitterList.prototype.getItems = function () {\n\t\treturn this.items.slice( 0 );\n\t};\n\n\t/**\n\t * Get the index of a specific item.\n\t *\n\t * @param {OO.EventEmitter} item Requested item\n\t * @return {number} Index of the item\n\t */\n\too.EmitterList.prototype.getItemIndex = function ( item ) {\n\t\treturn this.items.indexOf( item );\n\t};\n\n\t/**\n\t * Get number of items.\n\t *\n\t * @return {number} Number of items in the list\n\t */\n\too.EmitterList.prototype.getItemCount = function () {\n\t\treturn this.items.length;\n\t};\n\n\t/**\n\t * Check if a list contains no items.\n\t *\n\t * @return {boolean} Group is empty\n\t */\n\too.EmitterList.prototype.isEmpty = function () {\n\t\treturn !this.items.length;\n\t};\n\n\t/**\n\t * Aggregate the events emitted by the group.\n\t *\n\t * When events are aggregated, the group will listen to all contained items for the event,\n\t * and then emit the event under a new name. The new event will contain an additional leading\n\t * parameter containing the item that emitted the original event. Other arguments emitted from\n\t * the original event are passed through.\n\t *\n\t * @param {Object.<string,string|null>} events An object keyed by the name of the event that should be\n\t *  aggregated  (e.g., ‘click’) and the value of the new name to use (e.g., ‘groupClick’).\n\t *  A `null` value will remove aggregated events.\n\n\t * @throws {Error} If aggregation already exists\n\t */\n\too.EmitterList.prototype.aggregate = function ( events ) {\n\t\tvar i, item, add, remove, itemEvent, groupEvent;\n\n\t\tfor ( itemEvent in events ) {\n\t\t\tgroupEvent = events[ itemEvent ];\n\n\t\t\t// Remove existing aggregated event\n\t\t\tif ( Object.prototype.hasOwnProperty.call( this.aggregateItemEvents, itemEvent ) ) {\n\t\t\t\t// Don't allow duplicate aggregations\n\t\t\t\tif ( groupEvent ) {\n\t\t\t\t\tthrow new Error( 'Duplicate item event aggregation for ' + itemEvent );\n\t\t\t\t}\n\t\t\t\t// Remove event aggregation from existing items\n\t\t\t\tfor ( i = 0; i < this.items.length; i++ ) {\n\t\t\t\t\titem = this.items[ i ];\n\t\t\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\t\t\tremove = {};\n\t\t\t\t\t\tremove[ itemEvent ] = [ 'emit', this.aggregateItemEvents[ itemEvent ], item ];\n\t\t\t\t\t\titem.disconnect( this, remove );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// Prevent future items from aggregating event\n\t\t\t\tdelete this.aggregateItemEvents[ itemEvent ];\n\t\t\t}\n\n\t\t\t// Add new aggregate event\n\t\t\tif ( groupEvent ) {\n\t\t\t\t// Make future items aggregate event\n\t\t\t\tthis.aggregateItemEvents[ itemEvent ] = groupEvent;\n\t\t\t\t// Add event aggregation to existing items\n\t\t\t\tfor ( i = 0; i < this.items.length; i++ ) {\n\t\t\t\t\titem = this.items[ i ];\n\t\t\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\t\t\tadd = {};\n\t\t\t\t\t\tadd[ itemEvent ] = [ 'emit', groupEvent, item ];\n\t\t\t\t\t\titem.connect( this, add );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t};\n\n\t/**\n\t * Add items to the list.\n\t *\n\t * @param {OO.EventEmitter|OO.EventEmitter[]} items Item to add or\n\t *  an array of items to add\n\t * @param {number} [index] Index to add items at. If no index is\n\t *  given, or if the index that is given is invalid, the item\n\t *  will be added at the end of the list.\n\t * @chainable\n\t * @fires add\n\t * @fires move\n\t */\n\too.EmitterList.prototype.addItems = function ( items, index ) {\n\t\tvar i, oldIndex;\n\n\t\tif ( !Array.isArray( items ) ) {\n\t\t\titems = [ items ];\n\t\t}\n\n\t\tif ( items.length === 0 ) {\n\t\t\treturn this;\n\t\t}\n\n\t\tindex = normalizeArrayIndex( this.items, index );\n\t\tfor ( i = 0; i < items.length; i++ ) {\n\t\t\toldIndex = this.items.indexOf( items[ i ] );\n\t\t\tif ( oldIndex !== -1 ) {\n\t\t\t\t// Move item to new index\n\t\t\t\tindex = this.moveItem( items[ i ], index );\n\t\t\t\tthis.emit( 'move', items[ i ], index, oldIndex );\n\t\t\t} else {\n\t\t\t\t// insert item at index\n\t\t\t\tindex = this.insertItem( items[ i ], index );\n\t\t\t\tthis.emit( 'add', items[ i ], index );\n\t\t\t}\n\t\t\tindex++;\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Move an item from its current position to a new index.\n\t *\n\t * The item is expected to exist in the list. If it doesn't,\n\t * the method will throw an exception.\n\t *\n\t * @private\n\t * @param {OO.EventEmitter} item Items to add\n\t * @param {number} newIndex Index to move the item to\n\t * @return {number} The index the item was moved to\n\t * @throws {Error} If item is not in the list\n\t */\n\too.EmitterList.prototype.moveItem = function ( item, newIndex ) {\n\t\tvar existingIndex = this.items.indexOf( item );\n\n\t\tif ( existingIndex === -1 ) {\n\t\t\tthrow new Error( 'Item cannot be moved, because it is not in the list.' );\n\t\t}\n\n\t\tnewIndex = normalizeArrayIndex( this.items, newIndex );\n\n\t\t// Remove the item from the current index\n\t\tthis.items.splice( existingIndex, 1 );\n\n\t\t// Adjust new index after removal\n\t\tnewIndex--;\n\n\t\t// Move the item to the new index\n\t\tthis.items.splice( newIndex, 0, item );\n\n\t\treturn newIndex;\n\t};\n\n\t/**\n\t * Utility method to insert an item into the list, and\n\t * connect it to aggregate events.\n\t *\n\t * Don't call this directly unless you know what you're doing.\n\t * Use #addItems instead.\n\t *\n\t * @private\n\t * @param {OO.EventEmitter} item Items to add\n\t * @param {number} index Index to add items at\n\t * @return {number} The index the item was added at\n\t */\n\too.EmitterList.prototype.insertItem = function ( item, index ) {\n\t\tvar events, event;\n\n\t\t// Add the item to event aggregation\n\t\tif ( item.connect && item.disconnect ) {\n\t\t\tevents = {};\n\t\t\tfor ( event in this.aggregateItemEvents ) {\n\t\t\t\tevents[ event ] = [ 'emit', this.aggregateItemEvents[ event ], item ];\n\t\t\t}\n\t\t\titem.connect( this, events );\n\t\t}\n\n\t\tindex = normalizeArrayIndex( this.items, index );\n\n\t\t// Insert into items array\n\t\tthis.items.splice( index, 0, item );\n\t\treturn index;\n\t};\n\n\t/**\n\t * Remove items.\n\t *\n\t * @param {OO.EventEmitter[]} items Items to remove\n\t * @chainable\n\t * @fires remove\n\t */\n\too.EmitterList.prototype.removeItems = function ( items ) {\n\t\tvar i, item, index;\n\n\t\tif ( !Array.isArray( items ) ) {\n\t\t\titems = [ items ];\n\t\t}\n\n\t\tif ( items.length === 0 ) {\n\t\t\treturn this;\n\t\t}\n\n\t\t// Remove specific items\n\t\tfor ( i = 0; i < items.length; i++ ) {\n\t\t\titem = items[ i ];\n\t\t\tindex = this.items.indexOf( item );\n\t\t\tif ( index !== -1 ) {\n\t\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\t\t// Disconnect all listeners from the item\n\t\t\t\t\titem.disconnect( this );\n\t\t\t\t}\n\t\t\t\tthis.items.splice( index, 1 );\n\t\t\t\tthis.emit( 'remove', item, index );\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n\t/**\n\t * Clear all items\n\t *\n\t * @chainable\n\t * @fires clear\n\t */\n\too.EmitterList.prototype.clearItems = function () {\n\t\tvar i, item,\n\t\t\tcleared = this.items.splice( 0, this.items.length );\n\n\t\t// Disconnect all items\n\t\tfor ( i = 0; i < cleared.length; i++ ) {\n\t\t\titem = cleared[ i ];\n\t\t\tif ( item.connect && item.disconnect ) {\n\t\t\t\titem.disconnect( this );\n\t\t\t}\n\t\t}\n\n\t\tthis.emit( 'clear' );\n\n\t\treturn this;\n\t};\n\n}() );\n\n/**\n * Manage a sorted list of OO.EmitterList objects.\n *\n * The sort order is based on a callback that compares two items. The return value of\n * callback( a, b ) must be less than zero if a < b, greater than zero if a > b, and zero\n * if a is equal to b. The callback should only return zero if the two objects are\n * considered equal.\n *\n * When an item changes in a way that could affect their sorting behavior, it must\n * emit the itemSortChange event. This will cause it to be re-sorted automatically.\n *\n * This mixin must be used in a class that also mixes in OO.EventEmitter.\n *\n * @abstract\n * @class OO.SortedEmitterList\n * @mixins OO.EmitterList\n * @constructor\n * @param {Function} sortingCallback Callback that compares two items.\n */\noo.SortedEmitterList = function OoSortedEmitterList( sortingCallback ) {\n\t// Mixin constructors\n\too.EmitterList.call( this );\n\n\tthis.sortingCallback = sortingCallback;\n\n\t// Listen to sortChange event and make sure\n\t// we re-sort the changed item when that happens\n\tthis.aggregate( {\n\t\tsortChange: 'itemSortChange'\n\t} );\n\n\tthis.connect( this, {\n\t\titemSortChange: 'onItemSortChange'\n\t} );\n};\n\noo.mixinClass( oo.SortedEmitterList, oo.EmitterList );\n\n/* Events */\n\n/**\n * An item has changed properties that affect its sort positioning\n * inside the list.\n *\n * @private\n * @event itemSortChange\n */\n\n/* Methods */\n\n/**\n * Handle a case where an item changed a property that relates\n * to its sorted order\n *\n * @param {OO.EventEmitter} item Item in the list\n */\noo.SortedEmitterList.prototype.onItemSortChange = function ( item ) {\n\t// Remove the item\n\tthis.removeItems( item );\n\t// Re-add the item so it is in the correct place\n\tthis.addItems( item );\n};\n\n/**\n * Change the sorting callback for this sorted list.\n *\n * The callback receives two items. The return value of callback(a, b) must be less than zero\n * if a < b, greater than zero if a > b, and zero if a is equal to b.\n *\n * @param {Function} sortingCallback Sorting callback\n */\noo.SortedEmitterList.prototype.setSortingCallback = function ( sortingCallback ) {\n\tvar items = this.getItems();\n\n\tthis.sortingCallback = sortingCallback;\n\n\t// Empty the list\n\tthis.clearItems();\n\t// Re-add the items in the new order\n\tthis.addItems( items );\n};\n\n/**\n * Add items to the sorted list.\n *\n * @chainable\n * @param {OO.EventEmitter|OO.EventEmitter[]} items Item to add or\n *  an array of items to add\n */\noo.SortedEmitterList.prototype.addItems = function ( items ) {\n\tvar index, i, insertionIndex;\n\n\tif ( !Array.isArray( items ) ) {\n\t\titems = [ items ];\n\t}\n\n\tif ( items.length === 0 ) {\n\t\treturn this;\n\t}\n\n\tfor ( i = 0; i < items.length; i++ ) {\n\t\t// Find insertion index\n\t\tinsertionIndex = this.findInsertionIndex( items[ i ] );\n\n\t\t// Check if the item exists using the sorting callback\n\t\t// and remove it first if it exists\n\t\tif (\n\t\t\t// First make sure the insertion index is not at the end\n\t\t\t// of the list (which means it does not point to any actual\n\t\t\t// items)\n\t\t\tinsertionIndex <= this.items.length &&\n\t\t\t// Make sure there actually is an item in this index\n\t\t\tthis.items[ insertionIndex ] &&\n\t\t\t// The callback returns 0 if the items are equal\n\t\t\tthis.sortingCallback( this.items[ insertionIndex ], items[ i ] ) === 0\n\t\t) {\n\t\t\t// Remove the existing item\n\t\t\tthis.removeItems( this.items[ insertionIndex ] );\n\t\t}\n\n\t\t// Insert item at the insertion index\n\t\tindex = this.insertItem( items[ i ], insertionIndex );\n\t\tthis.emit( 'add', items[ i ], insertionIndex );\n\t}\n\n\treturn this;\n};\n\n/**\n * Find the index a given item should be inserted at. If the item is already\n * in the list, this will return the index where the item currently is.\n *\n * @param {OO.EventEmitter} item Items to insert\n * @return {number} The index the item should be inserted at\n */\noo.SortedEmitterList.prototype.findInsertionIndex = function ( item ) {\n\tvar list = this;\n\n\treturn oo.binarySearch(\n\t\tthis.items,\n\t\t// Fake a this.sortingCallback.bind( null, item ) call here\n\t\t// otherwise this doesn't pass tests in phantomJS\n\t\tfunction ( otherItem ) {\n\t\t\treturn list.sortingCallback( item, otherItem );\n\t\t},\n\t\ttrue\n\t);\n\n};\n\n/*global hasOwn */\n\n/**\n * @class OO.Registry\n * @mixins OO.EventEmitter\n *\n * @constructor\n */\noo.Registry = function OoRegistry() {\n\t// Mixin constructors\n\too.EventEmitter.call( this );\n\n\t// Properties\n\tthis.registry = {};\n};\n\n/* Inheritance */\n\noo.mixinClass( oo.Registry, oo.EventEmitter );\n\n/* Events */\n\n/**\n * @event register\n * @param {string} name\n * @param {Mixed} data\n */\n\n/**\n * @event unregister\n * @param {string} name\n * @param {Mixed} data Data removed from registry\n */\n\n/* Methods */\n\n/**\n * Associate one or more symbolic names with some data.\n *\n * Any existing entry with the same name will be overridden.\n *\n * @param {string|string[]} name Symbolic name or list of symbolic names\n * @param {Mixed} data Data to associate with symbolic name\n * @fires register\n * @throws {Error} Name argument must be a string or array\n */\noo.Registry.prototype.register = function ( name, data ) {\n\tvar i, len;\n\tif ( typeof name === 'string' ) {\n\t\tthis.registry[ name ] = data;\n\t\tthis.emit( 'register', name, data );\n\t} else if ( Array.isArray( name ) ) {\n\t\tfor ( i = 0, len = name.length; i < len; i++ ) {\n\t\t\tthis.register( name[ i ], data );\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Name must be a string or array, cannot be a ' + typeof name );\n\t}\n};\n\n/**\n * Remove one or more symbolic names from the registry\n *\n * @param {string|string[]} name Symbolic name or list of symbolic names\n * @fires unregister\n * @throws {Error} Name argument must be a string or array\n */\noo.Registry.prototype.unregister = function ( name ) {\n\tvar i, len, data;\n\tif ( typeof name === 'string' ) {\n\t\tdata = this.lookup( name );\n\t\tif ( data !== undefined ) {\n\t\t\tdelete this.registry[ name ];\n\t\t\tthis.emit( 'unregister', name, data );\n\t\t}\n\t} else if ( Array.isArray( name ) ) {\n\t\tfor ( i = 0, len = name.length; i < len; i++ ) {\n\t\t\tthis.unregister( name[ i ] );\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Name must be a string or array, cannot be a ' + typeof name );\n\t}\n};\n\n/**\n * Get data for a given symbolic name.\n *\n * @param {string} name Symbolic name\n * @return {Mixed|undefined} Data associated with symbolic name\n */\noo.Registry.prototype.lookup = function ( name ) {\n\tif ( hasOwn.call( this.registry, name ) ) {\n\t\treturn this.registry[ name ];\n\t}\n};\n\n/*global createObject */\n\n/**\n * @class OO.Factory\n * @extends OO.Registry\n *\n * @constructor\n */\noo.Factory = function OoFactory() {\n\t// Parent constructor\n\too.Factory.parent.call( this );\n};\n\n/* Inheritance */\n\noo.inheritClass( oo.Factory, oo.Registry );\n\n/* Methods */\n\n/**\n * Register a constructor with the factory.\n *\n * Classes must have a static `name` property to be registered.\n *\n *     function MyClass() {};\n *     OO.initClass( MyClass );\n *     // Adds a static property to the class defining a symbolic name\n *     MyClass.static.name = 'mine';\n *     // Registers class with factory, available via symbolic name 'mine'\n *     factory.register( MyClass );\n *\n * @param {Function} constructor Constructor to use when creating object\n * @throws {Error} Name must be a string and must not be empty\n * @throws {Error} Constructor must be a function\n */\noo.Factory.prototype.register = function ( constructor ) {\n\tvar name;\n\n\tif ( typeof constructor !== 'function' ) {\n\t\tthrow new Error( 'constructor must be a function, cannot be a ' + typeof constructor );\n\t}\n\tname = constructor.static && constructor.static.name;\n\tif ( typeof name !== 'string' || name === '' ) {\n\t\tthrow new Error( 'Name must be a string and must not be empty' );\n\t}\n\n\t// Parent method\n\too.Factory.parent.prototype.register.call( this, name, constructor );\n};\n\n/**\n * Unregister a constructor from the factory.\n *\n * @param {Function} constructor Constructor to unregister\n * @throws {Error} Name must be a string and must not be empty\n * @throws {Error} Constructor must be a function\n */\noo.Factory.prototype.unregister = function ( constructor ) {\n\tvar name;\n\n\tif ( typeof constructor !== 'function' ) {\n\t\tthrow new Error( 'constructor must be a function, cannot be a ' + typeof constructor );\n\t}\n\tname = constructor.static && constructor.static.name;\n\tif ( typeof name !== 'string' || name === '' ) {\n\t\tthrow new Error( 'Name must be a string and must not be empty' );\n\t}\n\n\t// Parent method\n\too.Factory.parent.prototype.unregister.call( this, name );\n};\n\n/**\n * Create an object based on a name.\n *\n * Name is used to look up the constructor to use, while all additional arguments are passed to the\n * constructor directly, so leaving one out will pass an undefined to the constructor.\n *\n * @param {string} name Object name\n * @param {...Mixed} [args] Arguments to pass to the constructor\n * @return {Object} The new object\n * @throws {Error} Unknown object name\n */\noo.Factory.prototype.create = function ( name ) {\n\tvar obj, i,\n\t\targs = [],\n\t\tconstructor = this.lookup( name );\n\n\tif ( !constructor ) {\n\t\tthrow new Error( 'No class registered by that name: ' + name );\n\t}\n\n\t// Convert arguments to array and shift the first argument (name) off\n\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\targs.push( arguments[ i ] );\n\t}\n\n\t// We can't use the \"new\" operator with .apply directly because apply needs a\n\t// context. So instead just do what \"new\" does: create an object that inherits from\n\t// the constructor's prototype (which also makes it an \"instanceof\" the constructor),\n\t// then invoke the constructor with the object as context, and return it (ignoring\n\t// the constructor's return value).\n\tobj = createObject( constructor.prototype );\n\tconstructor.apply( obj, args );\n\treturn obj;\n};\n\n/*jshint node:true */\nif ( typeof module !== 'undefined' && module.exports ) {\n\tmodule.exports = oo;\n} else {\n\tglobal.OO = oo;\n}\n\n}( this ) );\n"]}