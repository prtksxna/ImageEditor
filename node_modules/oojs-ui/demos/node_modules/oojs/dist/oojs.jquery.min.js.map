{"version":3,"file":"oojs.jquery.min.js","sources":["oojs.jquery.js"],"names":["global","simpleArrayCombine","a","b","includeB","i","ilen","isInB","bObj","result","length","push","oo","hasOwn","hasOwnProperty","createObject","toString","Object","create","Empty","prototype","properties","obj","call","constructor","value","initClass","fn","inheritClass","targetFn","originFn","Error","targetConstructor","parent","enumerable","writable","configurable","mixinClass","key","getProp","retval","arguments","undefined","setProp","prop","cloneObject","origin","r","getObjectValues","values","TypeError","compare","asymmetrical","aValue","bValue","aType","bType","k","nodeType","isEqualNode","copy","source","leafCallback","nodeCallback","destination","Array","isArray","clone","cloneNode","isPlainObject","getHash","val","JSON","stringify","keySortReplacer","normalized","keys","len","getHashObject","sort","unique","arr","reduce","current","indexOf","simpleArrayUnion","j","jlen","simpleArrayIntersection","simpleArrayDifference","$","validateMethod","method","context","EventEmitter","this","bindings","on","event","args","once","listener","eventEmitter","wrapper","off","apply","splice","emit","binding","slice","concat","connect","methods","disconnect","Registry","registry","register","name","data","unregister","lookup","Factory","module","exports","OO"],"mappings":";CAUE,SAAWA,GAEb,YAmfA,SAASC,GAAoBC,EAAGC,EAAGC,GAClC,GAAIC,GAAGC,EAAMC,EACZC,KACAC,IAED,KAAMJ,EAAI,EAAGC,EAAOH,EAAEO,OAAYJ,EAAJD,EAAUA,IACvCG,EAAML,EAAEE,KAAO,CAGhB,KAAMA,EAAI,EAAGC,EAAOJ,EAAEQ,OAAYJ,EAAJD,EAAUA,IACvCE,IAAUC,EAAMN,EAAEG,IACbE,IAAUH,GACdK,EAAOE,KAAMT,EAAEG,GAIjB,OAAOI,GAhgBR,GAMCG,MAEAC,EAASD,EAAGE,eAGZC,GAFWH,EAAGI,SAECC,OAAOC,QAAU,WAE/B,QAASC,MACT,MAAO,UAAWC,EAAWC,GAC5B,GAAIC,EAMJ,OALAH,GAAMC,UAAYA,EAClBE,EAAM,GAAIH,GACLE,GAAcR,EAAOU,KAAMF,EAAY,iBAC3CC,EAAIE,YAAcH,EAAWG,YAAYC,OAEnCH,MAaVV,GAAGc,UAAY,SAAWC,GACzBA,EAAAA,UAAYA,EAAAA,eAyCbf,EAAGgB,aAAe,SAAWC,EAAUC,GACtC,GAAKD,EAAST,oBAAqBU,GAClC,KAAM,IAAIC,OAAO,sCAGlB,IAAIC,GAAoBH,EAAST,UAAUI,WAM3CK,GAAS,SAAWA,EAASI,OAASH,EAEtCD,EAAST,UAAYL,EAAce,EAASV,WAE3CI,aACCC,MAAOO,EACPE,YAAY,EACZC,UAAU,EACVC,cAAc,KAKhBxB,EAAGc,UAAWI,GACdD,EAAAA,UAAkBd,EAAce,EAAAA,YAkCjClB,EAAGyB,WAAa,SAAWR,EAAUC,GACpC,GAAIQ,EAGJ,KAAMA,IAAOR,GAASV,UACR,gBAARkB,GAAyBzB,EAAOU,KAAMO,EAASV,UAAWkB,KAC9DT,EAAST,UAAUkB,GAAOR,EAASV,UAAUkB,GAM/C,IADA1B,EAAGc,UAAWG,GACTC,EAAAA,UACJ,IAAMQ,IAAOR,GAAAA,UACPjB,EAAOU,KAAMO,EAAAA,UAAiBQ,KAClCT,EAAAA,UAAgBS,GAAOR,EAAAA,UAAgBQ,QAIzC1B,GAAGc,UAAWI,IAmBhBlB,EAAG2B,QAAU,SAAWjB,GACvB,GAAIjB,GACHmC,EAASlB,CACV,KAAMjB,EAAI,EAAGA,EAAIoC,UAAU/B,OAAQL,IAAM,CACxC,GAAgBqC,SAAXF,GAAmC,OAAXA,EAE5B,MAAOE,OAERF,GAASA,EAAOC,UAAUpC,IAE3B,MAAOmC,IAiBR5B,EAAG+B,QAAU,SAAWrB,GACvB,GAAIjB,GACHuC,EAAOtB,CACR,IAAKL,OAAQK,KAAUA,EAAvB,CAGA,IAAMjB,EAAI,EAAGA,EAAIoC,UAAU/B,OAAS,EAAGL,IAAM,CAI5C,GAH4BqC,SAAvBE,EAAKH,UAAUpC,MACnBuC,EAAKH,UAAUpC,QAEXY,OAAQ2B,EAAKH,UAAUpC,OAAUuC,EAAKH,UAAUpC,IACpD,MAEDuC,GAAOA,EAAKH,UAAUpC,IAEvBuC,EAAKH,UAAUA,UAAU/B,OAAS,IAAM+B,UAAUA,UAAU/B,OAAS,KAyBtEE,EAAGiC,YAAc,SAAWC,GAC3B,GAAIR,GAAKS,CAETA,GAAIhC,EAAc+B,EAAOtB,YAAYJ,UAErC,KAAMkB,IAAOQ,GACPjC,EAAOU,KAAMuB,EAAQR,KACzBS,EAAET,GAAOQ,EAAOR,GAIlB,OAAOS,IASRnC,EAAGoC,gBAAkB,SAAW1B,GAC/B,GAAIgB,GAAKW,CAET,IAAK3B,IAAQL,OAAQK,GACpB,KAAM,IAAI4B,WAAW,uBAGtBD,KACA,KAAMX,IAAOhB,GACPT,EAAOU,KAAMD,EAAKgB,KACtBW,EAAOA,EAAOvC,QAAUY,EAAIgB,GAI9B,OAAOW,IAkBRrC,EAAGuC,QAAU,SAAWjD,EAAGC,EAAGiD,GAC7B,GAAIC,GAAQC,EAAQC,EAAOC,EAAOC,CAElC,IAAKvD,IAAMC,EACV,OAAO,CAMR,IAHAD,EAAIA,MACJC,EAAIA,MAEuB,gBAAfD,GAAEwD,UAAkD,kBAAlBxD,GAAEyD,YAC/C,MAAOzD,GAAEyD,YAAaxD,EAGvB,KAAMsD,IAAKvD,GACV,GAAMW,EAAOU,KAAMrB,EAAGuD,IAAgBf,SAATxC,EAAEuD,IAAoBvD,EAAEuD,KAAOtD,EAAEsD,KAQ9DJ,EAASnD,EAAEuD,GACXH,EAASnD,EAAEsD,GACXF,QAAeF,GACfG,QAAeF,GACVC,IAAUC,IAED,WAAVD,GAAgC,WAAVA,GAAgC,YAAVA,IAC9CF,IAAWC,GAEVD,IAAWpC,OAAQoC,KAAazC,EAAGuC,QAASE,EAAQC,GAAQ,IAC9D,OAAO,CAIT,OAAOF,IAAe,EAAOxC,EAAGuC,QAAShD,EAAGD,GAAG,IAahDU,EAAGgD,KAAO,SAAWC,EAAQC,EAAcC,GAC1C,GAAIzB,GAAK0B,CAET,IAAKD,IAEJC,EAAcD,EAAcF,GACPnB,SAAhBsB,GACJ,MAAOA,EAIT,IAAKC,MAAMC,QAASL,GAEnBG,EAAc,GAAIC,OAAOJ,EAAOnD,YAC1B,CAAA,GAAKmD,GAAkC,kBAAjBA,GAAOM,MAEnC,MAAOL,GAAeA,EAAcD,EAAOM,SAAYN,EAAOM,OACxD,IAAKN,GAAsC,kBAArBA,GAAOO,UAEnC,MAAON,GACNA,EAAcD,EAAOO,WAAW,IAChCP,EAAOO,WAAW,EACb,KAAKxD,EAAGyD,cAAeR,GAK7B,MAAOC,GAAeA,EAAcD,GAAWA,CAH/CG,MAOD,IAAM1B,IAAOuB,GACZG,EAAY1B,GAAO1B,EAAGgD,KAAMC,EAAOvB,GAAMwB,EAAcC,EAIxD,OAAOC,IAmBRpD,EAAG0D,QAAU,SAAWC,GACvB,MAAOC,MAAKC,UAAWF,EAAK3D,EAAG0D,QAAQI,kBAaxC9D,EAAG0D,QAAQI,gBAAkB,SAAWpC,EAAKiC,GAC5C,GAAII,GAAYC,EAAMvE,EAAGwE,CAKzB,IAJKN,GAAoC,kBAAtBA,GAAIO,gBAEtBP,EAAMA,EAAIO,iBAELb,MAAMC,QAASK,IAAStD,OAAQsD,KAAUA,EAe/C,MAAOA,EARP,KAJAI,KACAC,EAAO3D,OAAO2D,KAAML,GAAMQ,OAC1B1E,EAAI,EACJwE,EAAMD,EAAKlE,OACCmE,EAAJxE,EAASA,GAAK,EACrBsE,EAAWC,EAAKvE,IAAMkE,EAAIK,EAAKvE,GAEhC,OAAOsE,IAeT/D,EAAGoE,OAAS,SAAWC,GACtB,MAAOA,GAAIC,OAAQ,SAAWzE,EAAQ0E,GAIrC,MAHmC,KAA9B1E,EAAO2E,QAASD,IACpB1E,EAAOE,KAAMwE,GAEP1E,QAeTG,EAAGyE,iBAAmB,WACrB,GAAIhF,GAAGC,EAAM2E,EAAKK,EAAGC,EACpBjE,KACAb,IAED,KAAMJ,EAAI,EAAGC,EAAOmC,UAAU/B,OAAYJ,EAAJD,EAAUA,IAE/C,IADA4E,EAAMxC,UAAUpC,GACViF,EAAI,EAAGC,EAAON,EAAIvE,OAAY6E,EAAJD,EAAUA,IACnChE,EAAK2D,EAAIK,MACdhE,EAAK2D,EAAIK,KAAO,EAChB7E,EAAOE,KAAMsE,EAAIK,IAKpB,OAAO7E,IA+CRG,EAAG4E,wBAA0B,SAAWtF,EAAGC,GAC1C,MAAOF,GAAoBC,EAAGC,GAAG,IAYlCS,EAAG6E,sBAAwB,SAAWvF,EAAGC,GACxC,MAAOF,GAAoBC,EAAGC,GAAG,IAKlCS,EAAGyD,cAAgBqB,EAAErB,cAInB,WAkCD,QAASsB,GAAgBC,EAAQC,GAEhC,GAAuB,gBAAXD,GAAsB,CAEjC,GAAiBlD,SAAZmD,GAAqC,OAAZA,EAC7B,KAAM,IAAI9D,OAAO,gBAAkB6D,EAAS,oBAE7C,IAAgC,kBAApBC,GAAQD,GAGnB,KAAM,IAAI7D,OAAO,aAAe6D,EAAS,2BAEpC,IAAuB,kBAAXA,GAClB,KAAM,IAAI7D,OAAO,uDAxCnBnB,EAAGkF,aAAe,WAQjBC,KAAKC,aAGNpF,EAAGc,UAAWd,EAAGkF,cAgDjBlF,EAAGkF,aAAa1E,UAAU6E,GAAK,SAAWC,EAAON,EAAQO,EAAMN,GAC9D,GAAIG,EAgBJ,OAdAL,GAAgBC,EAAQC,GAGvBG,EADInF,EAAOU,KAAMwE,KAAKC,SAAUE,GACrBH,KAAKC,SAASE,GAGdH,KAAKC,SAASE,MAG1BF,EAASrF,MACRiF,OAAQA,EACRO,KAAMA,EACNN,QAAWpD,UAAU/B,OAAS,EAAM,KAAOmF,IAErCE,MAURnF,EAAGkF,aAAa1E,UAAUgF,KAAO,SAAWF,EAAOG,GAClD,GAAIC,GAAeP,KAClBQ,EAAU,WAET,MADAD,GAAaE,IAAKN,EAAOK,GAClBF,EAASI,MAAOV,KAAMtD,WAE/B,OAAOsD,MAAKE,GAAIC,EAAOK,IAaxB3F,EAAGkF,aAAa1E,UAAUoF,IAAM,SAAWN,EAAON,EAAQC,GACzD,GAAIxF,GAAG2F,CAEP,IAA0B,IAArBvD,UAAU/B,OAGd,aADOqF,MAAKC,SAASE,GACdH,IAKR,IAFAJ,EAAgBC,EAAQC,IAElBhF,EAAOU,KAAMwE,KAAKC,SAAUE,KAAYH,KAAKC,SAASE,GAAOxF,OAElE,MAAOqF,KAWR,KAPKtD,UAAU/B,OAAS,IACvBmF,EAAU,MAIXG,EAAWD,KAAKC,SAASE,GACzB7F,EAAI2F,EAAStF,OACLL,KACF2F,EAAS3F,GAAGuF,SAAWA,GAAUI,EAAS3F,GAAGwF,UAAYA,GAC7DG,EAASU,OAAQrG,EAAG,EAQtB,OAHyB,KAApB2F,EAAStF,cACNqF,MAAKC,SAASE,GAEfH,MAURnF,EAAGkF,aAAa1E,UAAUuF,KAAO,SAAWT,GAC3C,GACC7F,GAAGwE,EAAK+B,EAASZ,EAAUJ,EADxBO,IAGJ,IAAKtF,EAAOU,KAAMwE,KAAKC,SAAUE,GAAU,CAG1C,IADAF,EAAWD,KAAKC,SAASE,GAAOW,QAC1BxG,EAAI,EAAGwE,EAAMpC,UAAU/B,OAAYmE,EAAJxE,EAASA,IAC7C8F,EAAKxF,KAAM8B,UAAUpC,GAEtB,KAAMA,EAAI,EAAGwE,EAAMmB,EAAStF,OAAYmE,EAAJxE,EAASA,IAC5CuG,EAAUZ,EAAS3F,GAGlBuF,EAF8B,gBAAnBgB,GAAQhB,OAEVgB,EAAQf,QAASe,EAAQhB,QAEzBgB,EAAQhB,OAElBA,EAAOa,MACNG,EAAQf,QACRe,EAAQT,KAAOS,EAAQT,KAAKW,OAAQX,GAASA,EAG/C,QAAO,EAER,OAAO,GAaRvF,EAAGkF,aAAa1E,UAAU2F,QAAU,SAAWlB,EAASmB,GACvD,GAAIpB,GAAQO,EAAMD,CAElB,KAAMA,IAASc,GACdpB,EAASoB,EAAQd,GAEZjC,MAAMC,QAAS0B,IACnBO,EAAOP,EAAOiB,MAAO,GACrBjB,EAASA,EAAO,IAEhBO,KAGDJ,KAAKE,GAAIC,EAAON,EAAQO,EAAMN,EAE/B,OAAOE,OAYRnF,EAAGkF,aAAa1E,UAAU6F,WAAa,SAAWpB,EAASmB,GAC1D,GAAI3G,GAAG6F,EAAOF,CAEd,IAAKgB,EAEJ,IAAMd,IAASc,GACdjB,KAAKS,IAAKN,EAAOc,EAAQd,GAAQL,OAIlC,KAAMK,IAASH,MAAKC,SAGnB,IAFAA,EAAWD,KAAKC,SAASE,GACzB7F,EAAI2F,EAAStF,OACLL,KAGF2F,EAAS3F,IAAM2F,EAAS3F,GAAGwF,UAAYA,GAC3CE,KAAKS,IAAKN,EAAOF,EAAS3F,GAAGuF,OAAQC,EAMzC,OAAOE,UAaTnF,EAAGsG,SAAW,WAEbtG,EAAGkF,aAAavE,KAAMwE,MAGtBA,KAAKoB,aAKNvG,EAAGyB,WAAYzB,EAAGsG,SAAUtG,EAAGkF,cA4B/BlF,EAAGsG,SAAS9F,UAAUgG,SAAW,SAAWC,EAAMC,GACjD,GAAIjH,GAAGwE,CACP,IAAqB,gBAATwC,GACXtB,KAAKoB,SAASE,GAAQC,EACtBvB,KAAKY,KAAM,WAAYU,EAAMC,OACvB,CAAA,IAAKrD,MAAMC,QAASmD,GAK1B,KAAM,IAAItF,OAAO,qDAAwDsF,GAJzE,KAAMhH,EAAI,EAAGwE,EAAMwC,EAAK3G,OAAYmE,EAAJxE,EAASA,IACxC0F,KAAKqB,SAAUC,EAAKhH,GAAIiH,KAc3B1G,EAAGsG,SAAS9F,UAAUmG,WAAa,SAAWF,GAC7C,GAAIhH,GAAGwE,EAAKyC,CACZ,IAAqB,gBAATD,GACXC,EAAOvB,KAAKyB,OAAQH,GACN3E,SAAT4E,UACGvB,MAAKoB,SAASE,GACrBtB,KAAKY,KAAM,aAAcU,EAAMC,QAE1B,CAAA,IAAKrD,MAAMC,QAASmD,GAK1B,KAAM,IAAItF,OAAO,qDAAwDsF,GAJzE,KAAMhH,EAAI,EAAGwE,EAAMwC,EAAK3G,OAAYmE,EAAJxE,EAASA,IACxC0F,KAAKwB,WAAYF,EAAKhH,MAazBO,EAAGsG,SAAS9F,UAAUoG,OAAS,SAAWH,GACzC,MAAKxG,GAAOU,KAAMwE,KAAKoB,SAAUE,GACzBtB,KAAKoB,SAASE,GADtB,QAaDzG,EAAG6G,QAAU,WAEZ7G,EAAG6G,QAAQxF,OAAOV,KAAMwE,OAKzBnF,EAAGgB,aAAchB,EAAG6G,QAAS7G,EAAGsG,UAoBhCtG,EAAG6G,QAAQrG,UAAUgG,SAAW,SAAW5F,GAC1C,GAAI6F,EAEJ,IAA4B,kBAAhB7F,GACX,KAAM,IAAIO,OAAO,qDAAwDP,GAG1E,IADA6F,EAAO7F,EAAAA,WAAsBA,EAAAA,UAAmB6F,KAC3B,gBAATA,IAA8B,KAATA,EAChC,KAAM,IAAItF,OAAO,8CAIlBnB,GAAG6G,QAAQxF,OAAOb,UAAUgG,SAAS7F,KAAMwE,KAAMsB,EAAM7F,IAUxDZ,EAAG6G,QAAQrG,UAAUmG,WAAa,SAAW/F,GAC5C,GAAI6F,EAEJ,IAA4B,kBAAhB7F,GACX,KAAM,IAAIO,OAAO,qDAAwDP,GAG1E,IADA6F,EAAO7F,EAAAA,WAAsBA,EAAAA,UAAmB6F,KAC3B,gBAATA,IAA8B,KAATA,EAChC,KAAM,IAAItF,OAAO,8CAIlBnB,GAAG6G,QAAQxF,OAAOb,UAAUmG,WAAWhG,KAAMwE,KAAMsB,IAcpDzG,EAAG6G,QAAQrG,UAAUF,OAAS,SAAWmG,GACxC,GAAI/F,GAAKjB,EACR8F,KACA3E,EAAcuE,KAAKyB,OAAQH,EAE5B,KAAM7F,EACL,KAAM,IAAIO,OAAO,qCAAuCsF,EAIzD,KAAMhH,EAAI,EAAGA,EAAIoC,UAAU/B,OAAQL,IAClC8F,EAAKxF,KAAM8B,UAAUpC,GAUtB,OAFAiB,GAAMP,EAAcS,EAAYJ,WAChCI,EAAYiF,MAAOnF,EAAK6E,GACjB7E,GAIe,mBAAXoG,SAA0BA,OAAOC,QAC5CD,OAAOC,QAAU/G,EAEjBZ,EAAO4H,GAAKhH,GAGVmF","sourcesContent":["/*!\n * OOjs v1.1.9 optimised for jQuery\n * https://www.mediawiki.org/wiki/OOjs\n *\n * Copyright 2011-2015 OOjs Team and other contributors.\n * Released under the MIT license\n * http://oojs.mit-license.org\n *\n * Date: 2015-08-25T21:35:29Z\n */\n( function ( global ) {\n\n'use strict';\n\n/*exported toString */\nvar\n\t/**\n\t * Namespace for all classes, static methods and static properties.\n\t * @class OO\n\t * @singleton\n\t */\n\too = {},\n\t// Optimisation: Local reference to Object.prototype.hasOwnProperty\n\thasOwn = oo.hasOwnProperty,\n\ttoString = oo.toString,\n\t// Object.create() is impossible to fully polyfill, so don't require it\n\tcreateObject = Object.create || ( function () {\n\t\t// Reusable constructor function\n\t\tfunction Empty() {}\n\t\treturn function ( prototype, properties ) {\n\t\t\tvar obj;\n\t\t\tEmpty.prototype = prototype;\n\t\t\tobj = new Empty();\n\t\t\tif ( properties && hasOwn.call( properties, 'constructor' ) ) {\n\t\t\t\tobj.constructor = properties.constructor.value;\n\t\t\t}\n\t\t\treturn obj;\n\t\t};\n\t} )();\n\n/* Class Methods */\n\n/**\n * Utility to initialize a class for OO inheritance.\n *\n * Currently this just initializes an empty static object.\n *\n * @param {Function} fn\n */\noo.initClass = function ( fn ) {\n\tfn.static = fn.static || {};\n};\n\n/**\n * Inherit from prototype to another using Object#create.\n *\n * Beware: This redefines the prototype, call before setting your prototypes.\n *\n * Beware: This redefines the prototype, can only be called once on a function.\n * If called multiple times on the same function, the previous prototype is lost.\n * This is how prototypal inheritance works, it can only be one straight chain\n * (just like classical inheritance in PHP for example). If you need to work with\n * multiple constructors consider storing an instance of the other constructor in a\n * property instead, or perhaps use a mixin (see OO.mixinClass).\n *\n *     function Thing() {}\n *     Thing.prototype.exists = function () {};\n *\n *     function Person() {\n *         Person.super.apply( this, arguments );\n *     }\n *     OO.inheritClass( Person, Thing );\n *     Person.static.defaultEyeCount = 2;\n *     Person.prototype.walk = function () {};\n *\n *     function Jumper() {\n *         Jumper.super.apply( this, arguments );\n *     }\n *     OO.inheritClass( Jumper, Person );\n *     Jumper.prototype.jump = function () {};\n *\n *     Jumper.static.defaultEyeCount === 2;\n *     var x = new Jumper();\n *     x.jump();\n *     x.walk();\n *     x instanceof Thing && x instanceof Person && x instanceof Jumper;\n *\n * @param {Function} targetFn\n * @param {Function} originFn\n * @throws {Error} If target already inherits from origin\n */\noo.inheritClass = function ( targetFn, originFn ) {\n\tif ( targetFn.prototype instanceof originFn ) {\n\t\tthrow new Error( 'Target already inherits from origin' );\n\t}\n\n\tvar targetConstructor = targetFn.prototype.constructor;\n\n\t// Using ['super'] instead of .super because 'super' is not supported\n\t// by IE 8 and below (bug 63303).\n\t// Provide .parent as alias for code supporting older browsers which\n\t// allows people to comply with their style guide.\n\ttargetFn['super'] = targetFn.parent = originFn;\n\n\ttargetFn.prototype = createObject( originFn.prototype, {\n\t\t// Restore constructor property of targetFn\n\t\tconstructor: {\n\t\t\tvalue: targetConstructor,\n\t\t\tenumerable: false,\n\t\t\twritable: true,\n\t\t\tconfigurable: true\n\t\t}\n\t} );\n\n\t// Extend static properties - always initialize both sides\n\too.initClass( originFn );\n\ttargetFn.static = createObject( originFn.static );\n};\n\n/**\n * Copy over *own* prototype properties of a mixin.\n *\n * The 'constructor' (whether implicit or explicit) is not copied over.\n *\n * This does not create inheritance to the origin. If you need inheritance,\n * use OO.inheritClass instead.\n *\n * Beware: This can redefine a prototype property, call before setting your prototypes.\n *\n * Beware: Don't call before OO.inheritClass.\n *\n *     function Foo() {}\n *     function Context() {}\n *\n *     // Avoid repeating this code\n *     function ContextLazyLoad() {}\n *     ContextLazyLoad.prototype.getContext = function () {\n *         if ( !this.context ) {\n *             this.context = new Context();\n *         }\n *         return this.context;\n *     };\n *\n *     function FooBar() {}\n *     OO.inheritClass( FooBar, Foo );\n *     OO.mixinClass( FooBar, ContextLazyLoad );\n *\n * @param {Function} targetFn\n * @param {Function} originFn\n */\noo.mixinClass = function ( targetFn, originFn ) {\n\tvar key;\n\n\t// Copy prototype properties\n\tfor ( key in originFn.prototype ) {\n\t\tif ( key !== 'constructor' && hasOwn.call( originFn.prototype, key ) ) {\n\t\t\ttargetFn.prototype[key] = originFn.prototype[key];\n\t\t}\n\t}\n\n\t// Copy static properties - always initialize both sides\n\too.initClass( targetFn );\n\tif ( originFn.static ) {\n\t\tfor ( key in originFn.static ) {\n\t\t\tif ( hasOwn.call( originFn.static, key ) ) {\n\t\t\t\ttargetFn.static[key] = originFn.static[key];\n\t\t\t}\n\t\t}\n\t} else {\n\t\too.initClass( originFn );\n\t}\n};\n\n/* Object Methods */\n\n/**\n * Get a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors.\n *\n * `quux = oo.getProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `quux = obj.foo.bar.baz;`\n * except that the former protects against JS errors if one of the intermediate properties\n * is undefined. Instead of throwing an error, this function will return undefined in\n * that case.\n *\n * @param {Object} obj\n * @param {Mixed...} [keys]\n * @return obj[arguments[1]][arguments[2]].... or undefined\n */\noo.getProp = function ( obj ) {\n\tvar i,\n\t\tretval = obj;\n\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\tif ( retval === undefined || retval === null ) {\n\t\t\t// Trying to access a property of undefined or null causes an error\n\t\t\treturn undefined;\n\t\t}\n\t\tretval = retval[arguments[i]];\n\t}\n\treturn retval;\n};\n\n/**\n * Set a deeply nested property of an object using variadic arguments, protecting against\n * undefined property errors.\n *\n * `oo.setProp( obj, 'foo', 'bar', 'baz' );` is equivalent to `obj.foo.bar = baz;` except that\n * the former protects against JS errors if one of the intermediate properties is\n * undefined. Instead of throwing an error, undefined intermediate properties will be\n * initialized to an empty object. If an intermediate property is not an object, or if obj itself\n * is not an object, this function will silently abort.\n *\n * @param {Object} obj\n * @param {Mixed...} [keys]\n * @param {Mixed} [value]\n */\noo.setProp = function ( obj ) {\n\tvar i,\n\t\tprop = obj;\n\tif ( Object( obj ) !== obj ) {\n\t\treturn;\n\t}\n\tfor ( i = 1; i < arguments.length - 2; i++ ) {\n\t\tif ( prop[arguments[i]] === undefined ) {\n\t\t\tprop[arguments[i]] = {};\n\t\t}\n\t\tif ( Object( prop[arguments[i]] ) !== prop[arguments[i]] ) {\n\t\t\treturn;\n\t\t}\n\t\tprop = prop[arguments[i]];\n\t}\n\tprop[arguments[arguments.length - 2]] = arguments[arguments.length - 1];\n};\n\n/**\n * Create a new object that is an instance of the same\n * constructor as the input, inherits from the same object\n * and contains the same own properties.\n *\n * This makes a shallow non-recursive copy of own properties.\n * To create a recursive copy of plain objects, use #copy.\n *\n *     var foo = new Person( mom, dad );\n *     foo.setAge( 21 );\n *     var foo2 = OO.cloneObject( foo );\n *     foo.setAge( 22 );\n *\n *     // Then\n *     foo2 !== foo; // true\n *     foo2 instanceof Person; // true\n *     foo2.getAge(); // 21\n *     foo.getAge(); // 22\n *\n * @param {Object} origin\n * @return {Object} Clone of origin\n */\noo.cloneObject = function ( origin ) {\n\tvar key, r;\n\n\tr = createObject( origin.constructor.prototype );\n\n\tfor ( key in origin ) {\n\t\tif ( hasOwn.call( origin, key ) ) {\n\t\t\tr[key] = origin[key];\n\t\t}\n\t}\n\n\treturn r;\n};\n\n/**\n * Get an array of all property values in an object.\n *\n * @param {Object} Object to get values from\n * @return {Array} List of object values\n */\noo.getObjectValues = function ( obj ) {\n\tvar key, values;\n\n\tif ( obj !== Object( obj ) ) {\n\t\tthrow new TypeError( 'Called on non-object' );\n\t}\n\n\tvalues = [];\n\tfor ( key in obj ) {\n\t\tif ( hasOwn.call( obj, key ) ) {\n\t\t\tvalues[values.length] = obj[key];\n\t\t}\n\t}\n\n\treturn values;\n};\n\n/**\n * Recursively compare properties between two objects.\n *\n * A false result may be caused by property inequality or by properties in one object missing from\n * the other. An asymmetrical test may also be performed, which checks only that properties in the\n * first object are present in the second object, but not the inverse.\n *\n * If either a or b is null or undefined it will be treated as an empty object.\n *\n * @param {Object|undefined|null} a First object to compare\n * @param {Object|undefined|null} b Second object to compare\n * @param {boolean} [asymmetrical] Whether to check only that a's values are equal to b's\n *  (i.e. a is a subset of b)\n * @return {boolean} If the objects contain the same values as each other\n */\noo.compare = function ( a, b, asymmetrical ) {\n\tvar aValue, bValue, aType, bType, k;\n\n\tif ( a === b ) {\n\t\treturn true;\n\t}\n\n\ta = a || {};\n\tb = b || {};\n\n\tif ( typeof a.nodeType === 'number' && typeof a.isEqualNode === 'function' ) {\n\t\treturn a.isEqualNode( b );\n\t}\n\n\tfor ( k in a ) {\n\t\tif ( !hasOwn.call( a, k ) || a[k] === undefined || a[k] === b[k] ) {\n\t\t\t// Support es3-shim: Without the hasOwn filter, comparing [] to {} will be false in ES3\n\t\t\t// because the shimmed \"forEach\" is enumerable and shows up in Array but not Object.\n\t\t\t// Also ignore undefined values, because there is no conceptual difference between\n\t\t\t// a key that is absent and a key that is present but whose value is undefined.\n\t\t\tcontinue;\n\t\t}\n\n\t\taValue = a[k];\n\t\tbValue = b[k];\n\t\taType = typeof aValue;\n\t\tbType = typeof bValue;\n\t\tif ( aType !== bType ||\n\t\t\t(\n\t\t\t\t( aType === 'string' || aType === 'number' || aType === 'boolean' ) &&\n\t\t\t\taValue !== bValue\n\t\t\t) ||\n\t\t\t( aValue === Object( aValue ) && !oo.compare( aValue, bValue, true ) ) ) {\n\t\t\treturn false;\n\t\t}\n\t}\n\t// If the check is not asymmetrical, recursing with the arguments swapped will verify our result\n\treturn asymmetrical ? true : oo.compare( b, a, true );\n};\n\n/**\n * Create a plain deep copy of any kind of object.\n *\n * Copies are deep, and will either be an object or an array depending on `source`.\n *\n * @param {Object} source Object to copy\n * @param {Function} [leafCallback] Applied to leaf values after they are cloned but before they are added to the clone\n * @param {Function} [nodeCallback] Applied to all values before they are cloned.  If the nodeCallback returns a value other than undefined, the returned value is used instead of attempting to clone.\n * @return {Object} Copy of source object\n */\noo.copy = function ( source, leafCallback, nodeCallback ) {\n\tvar key, destination;\n\n\tif ( nodeCallback ) {\n\t\t// Extensibility: check before attempting to clone source.\n\t\tdestination = nodeCallback( source );\n\t\tif ( destination !== undefined ) {\n\t\t\treturn destination;\n\t\t}\n\t}\n\n\tif ( Array.isArray( source ) ) {\n\t\t// Array (fall through)\n\t\tdestination = new Array( source.length );\n\t} else if ( source && typeof source.clone === 'function' ) {\n\t\t// Duck type object with custom clone method\n\t\treturn leafCallback ? leafCallback( source.clone() ) : source.clone();\n\t} else if ( source && typeof source.cloneNode === 'function' ) {\n\t\t// DOM Node\n\t\treturn leafCallback ?\n\t\t\tleafCallback( source.cloneNode( true ) ) :\n\t\t\tsource.cloneNode( true );\n\t} else if ( oo.isPlainObject( source ) ) {\n\t\t// Plain objects (fall through)\n\t\tdestination = {};\n\t} else {\n\t\t// Non-plain objects (incl. functions) and primitive values\n\t\treturn leafCallback ? leafCallback( source ) : source;\n\t}\n\n\t// source is an array or a plain object\n\tfor ( key in source ) {\n\t\tdestination[key] = oo.copy( source[key], leafCallback, nodeCallback );\n\t}\n\n\t// This is an internal node, so we don't apply the leafCallback.\n\treturn destination;\n};\n\n/**\n * Generate a hash of an object based on its name and data.\n *\n * Performance optimization: <http://jsperf.com/ve-gethash-201208#/toJson_fnReplacerIfAoForElse>\n *\n * To avoid two objects with the same values generating different hashes, we utilize the replacer\n * argument of JSON.stringify and sort the object by key as it's being serialized. This may or may\n * not be the fastest way to do this; we should investigate this further.\n *\n * Objects and arrays are hashed recursively. When hashing an object that has a .getHash()\n * function, we call that function and use its return value rather than hashing the object\n * ourselves. This allows classes to define custom hashing.\n *\n * @param {Object} val Object to generate hash for\n * @return {string} Hash of object\n */\noo.getHash = function ( val ) {\n\treturn JSON.stringify( val, oo.getHash.keySortReplacer );\n};\n\n/**\n * Sort objects by key (helper function for OO.getHash).\n *\n * This is a callback passed into JSON.stringify.\n *\n * @method getHash_keySortReplacer\n * @param {string} key Property name of value being replaced\n * @param {Mixed} val Property value to replace\n * @return {Mixed} Replacement value\n */\noo.getHash.keySortReplacer = function ( key, val ) {\n\tvar normalized, keys, i, len;\n\tif ( val && typeof val.getHashObject === 'function' ) {\n\t\t// This object has its own custom hash function, use it\n\t\tval = val.getHashObject();\n\t}\n\tif ( !Array.isArray( val ) && Object( val ) === val ) {\n\t\t// Only normalize objects when the key-order is ambiguous\n\t\t// (e.g. any object not an array).\n\t\tnormalized = {};\n\t\tkeys = Object.keys( val ).sort();\n\t\ti = 0;\n\t\tlen = keys.length;\n\t\tfor ( ; i < len; i += 1 ) {\n\t\t\tnormalized[keys[i]] = val[keys[i]];\n\t\t}\n\t\treturn normalized;\n\n\t// Primitive values and arrays get stable hashes\n\t// by default. Lets those be stringified as-is.\n\t} else {\n\t\treturn val;\n\t}\n};\n\n/**\n * Get the unique values of an array, removing duplicates\n *\n * @param {Array} arr Array\n * @return {Array} Unique values in array\n */\noo.unique = function ( arr ) {\n\treturn arr.reduce( function ( result, current ) {\n\t\tif ( result.indexOf( current ) === -1 ) {\n\t\t\tresult.push( current );\n\t\t}\n\t\treturn result;\n\t}, [] );\n};\n\n/**\n * Compute the union (duplicate-free merge) of a set of arrays.\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * By building an object (with the values for keys) in parallel with\n * the array, a new item's existence in the union can be computed faster.\n *\n * @param {Array...} arrays Arrays to union\n * @return {Array} Union of the arrays\n */\noo.simpleArrayUnion = function () {\n\tvar i, ilen, arr, j, jlen,\n\t\tobj = {},\n\t\tresult = [];\n\n\tfor ( i = 0, ilen = arguments.length; i < ilen; i++ ) {\n\t\tarr = arguments[i];\n\t\tfor ( j = 0, jlen = arr.length; j < jlen; j++ ) {\n\t\t\tif ( !obj[ arr[j] ] ) {\n\t\t\t\tobj[ arr[j] ] = true;\n\t\t\t\tresult.push( arr[j] );\n\t\t\t}\n\t\t}\n\t}\n\n\treturn result;\n};\n\n/**\n * Combine arrays (intersection or difference).\n *\n * An intersection checks the item exists in 'b' while difference checks it doesn't.\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * By building an object (with the values for keys) of 'b' we can\n * compute the result faster.\n *\n * @private\n * @param {Array} a First array\n * @param {Array} b Second array\n * @param {boolean} includeB Whether to items in 'b'\n * @return {Array} Combination (intersection or difference) of arrays\n */\nfunction simpleArrayCombine( a, b, includeB ) {\n\tvar i, ilen, isInB,\n\t\tbObj = {},\n\t\tresult = [];\n\n\tfor ( i = 0, ilen = b.length; i < ilen; i++ ) {\n\t\tbObj[ b[i] ] = true;\n\t}\n\n\tfor ( i = 0, ilen = a.length; i < ilen; i++ ) {\n\t\tisInB = !!bObj[ a[i] ];\n\t\tif ( isInB === includeB ) {\n\t\t\tresult.push( a[i] );\n\t\t}\n\t}\n\n\treturn result;\n}\n\n/**\n * Compute the intersection of two arrays (items in both arrays).\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * @param {Array} a First array\n * @param {Array} b Second array\n * @return {Array} Intersection of arrays\n */\noo.simpleArrayIntersection = function ( a, b ) {\n\treturn simpleArrayCombine( a, b, true );\n};\n\n/**\n * Compute the difference of two arrays (items in 'a' but not 'b').\n *\n * Arrays values must be convertable to object keys (strings).\n *\n * @param {Array} a First array\n * @param {Array} b Second array\n * @return {Array} Intersection of arrays\n */\noo.simpleArrayDifference = function ( a, b ) {\n\treturn simpleArrayCombine( a, b, false );\n};\n\n/*global $ */\n\noo.isPlainObject = $.isPlainObject;\n\n/*global hasOwn */\n\n( function () {\n\n\t/**\n\t * @class OO.EventEmitter\n\t *\n\t * @constructor\n\t */\n\too.EventEmitter = function OoEventEmitter() {\n\t\t// Properties\n\n\t\t/**\n\t\t * Storage of bound event handlers by event name.\n\t\t *\n\t\t * @property\n\t\t */\n\t\tthis.bindings = {};\n\t};\n\n\too.initClass( oo.EventEmitter );\n\n\t/* Private helper functions */\n\n\t/**\n\t * Validate a function or method call in a context\n\t *\n\t * For a method name, check that it names a function in the context object\n\t *\n\t * @private\n\t * @param {Function|string} method Function or method name\n\t * @param {Mixed} context The context of the call\n\t * @throws {Error} A method name is given but there is no context\n\t * @throws {Error} In the context object, no property exists with the given name\n\t * @throws {Error} In the context object, the named property is not a function\n\t */\n\tfunction validateMethod( method, context ) {\n\t\t// Validate method and context\n\t\tif ( typeof method === 'string' ) {\n\t\t\t// Validate method\n\t\t\tif ( context === undefined || context === null ) {\n\t\t\t\tthrow new Error( 'Method name \"' + method + '\" has no context.' );\n\t\t\t}\n\t\t\tif ( typeof context[method] !== 'function' ) {\n\t\t\t\t// Technically the property could be replaced by a function before\n\t\t\t\t// call time. But this probably signals a typo.\n\t\t\t\tthrow new Error( 'Property \"' + method + '\" is not a function' );\n\t\t\t}\n\t\t} else if ( typeof method !== 'function' ) {\n\t\t\tthrow new Error( 'Invalid callback. Function or method name expected.' );\n\t\t}\n\t}\n\n\t/* Methods */\n\n\t/**\n\t * Add a listener to events of a specific event.\n\t *\n\t * The listener can be a function or the string name of a method; if the latter, then the\n\t * name lookup happens at the time the listener is called.\n\t *\n\t * @param {string} event Type of event to listen to\n\t * @param {Function|string} method Function or method name to call when event occurs\n\t * @param {Array} [args] Arguments to pass to listener, will be prepended to emitted arguments\n\t * @param {Object} [context=null] Context object for function or method call\n\t * @throws {Error} Listener argument is not a function or a valid method name\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.on = function ( event, method, args, context ) {\n\t\tvar bindings;\n\n\t\tvalidateMethod( method, context );\n\n\t\tif ( hasOwn.call( this.bindings, event ) ) {\n\t\t\tbindings = this.bindings[event];\n\t\t} else {\n\t\t\t// Auto-initialize bindings list\n\t\t\tbindings = this.bindings[event] = [];\n\t\t}\n\t\t// Add binding\n\t\tbindings.push( {\n\t\t\tmethod: method,\n\t\t\targs: args,\n\t\t\tcontext: ( arguments.length < 4 ) ? null : context\n\t\t} );\n\t\treturn this;\n\t};\n\n\t/**\n\t * Add a one-time listener to a specific event.\n\t *\n\t * @param {string} event Type of event to listen to\n\t * @param {Function} listener Listener to call when event occurs\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.once = function ( event, listener ) {\n\t\tvar eventEmitter = this,\n\t\t\twrapper = function () {\n\t\t\t\teventEmitter.off( event, wrapper );\n\t\t\t\treturn listener.apply( this, arguments );\n\t\t\t};\n\t\treturn this.on( event, wrapper );\n\t};\n\n\t/**\n\t * Remove a specific listener from a specific event.\n\t *\n\t * @param {string} event Type of event to remove listener from\n\t * @param {Function|string} [method] Listener to remove. Must be in the same form as was passed\n\t * to \"on\". Omit to remove all listeners.\n\t * @param {Object} [context=null] Context object function or method call\n\t * @chainable\n\t * @throws {Error} Listener argument is not a function or a valid method name\n\t */\n\too.EventEmitter.prototype.off = function ( event, method, context ) {\n\t\tvar i, bindings;\n\n\t\tif ( arguments.length === 1 ) {\n\t\t\t// Remove all bindings for event\n\t\t\tdelete this.bindings[event];\n\t\t\treturn this;\n\t\t}\n\n\t\tvalidateMethod( method, context );\n\n\t\tif ( !hasOwn.call( this.bindings, event ) || !this.bindings[event].length ) {\n\t\t\t// No matching bindings\n\t\t\treturn this;\n\t\t}\n\n\t\t// Default to null context\n\t\tif ( arguments.length < 3 ) {\n\t\t\tcontext = null;\n\t\t}\n\n\t\t// Remove matching handlers\n\t\tbindings = this.bindings[event];\n\t\ti = bindings.length;\n\t\twhile ( i-- ) {\n\t\t\tif ( bindings[i].method === method && bindings[i].context === context ) {\n\t\t\t\tbindings.splice( i, 1 );\n\t\t\t}\n\t\t}\n\n\t\t// Cleanup if now empty\n\t\tif ( bindings.length === 0 ) {\n\t\t\tdelete this.bindings[event];\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Emit an event.\n\t *\n\t * @param {string} event Type of event\n\t * @param {Mixed} args First in a list of variadic arguments passed to event handler (optional)\n\t * @return {boolean} Whether the event was handled by at least one listener\n\t */\n\too.EventEmitter.prototype.emit = function ( event ) {\n\t\tvar args = [],\n\t\t\ti, len, binding, bindings, method;\n\n\t\tif ( hasOwn.call( this.bindings, event ) ) {\n\t\t\t// Slicing ensures that we don't get tripped up by event handlers that add/remove bindings\n\t\t\tbindings = this.bindings[event].slice();\n\t\t\tfor ( i = 1, len = arguments.length; i < len; i++ ) {\n\t\t\t\targs.push( arguments[i] );\n\t\t\t}\n\t\t\tfor ( i = 0, len = bindings.length; i < len; i++ ) {\n\t\t\t\tbinding = bindings[i];\n\t\t\t\tif ( typeof binding.method === 'string' ) {\n\t\t\t\t\t// Lookup method by name (late binding)\n\t\t\t\t\tmethod = binding.context[ binding.method ];\n\t\t\t\t} else {\n\t\t\t\t\tmethod = binding.method;\n\t\t\t\t}\n\t\t\t\tmethod.apply(\n\t\t\t\t\tbinding.context,\n\t\t\t\t\tbinding.args ? binding.args.concat( args ) : args\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t};\n\n\t/**\n\t * Connect event handlers to an object.\n\t *\n\t * @param {Object} context Object to call methods on when events occur\n\t * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} methods List of\n\t *  event bindings keyed by event name containing either method names, functions or arrays containing\n\t *  method name or function followed by a list of arguments to be passed to callback before emitted\n\t *  arguments\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.connect = function ( context, methods ) {\n\t\tvar method, args, event;\n\n\t\tfor ( event in methods ) {\n\t\t\tmethod = methods[event];\n\t\t\t// Allow providing additional args\n\t\t\tif ( Array.isArray( method ) ) {\n\t\t\t\targs = method.slice( 1 );\n\t\t\t\tmethod = method[0];\n\t\t\t} else {\n\t\t\t\targs = [];\n\t\t\t}\n\t\t\t// Add binding\n\t\t\tthis.on( event, method, args, context );\n\t\t}\n\t\treturn this;\n\t};\n\n\t/**\n\t * Disconnect event handlers from an object.\n\t *\n\t * @param {Object} context Object to disconnect methods from\n\t * @param {Object.<string,string>|Object.<string,Function>|Object.<string,Array>} [methods] List of\n\t * event bindings keyed by event name. Values can be either method names or functions, but must be\n\t * consistent with those used in the corresponding call to \"connect\".\n\t * @chainable\n\t */\n\too.EventEmitter.prototype.disconnect = function ( context, methods ) {\n\t\tvar i, event, bindings;\n\n\t\tif ( methods ) {\n\t\t\t// Remove specific connections to the context\n\t\t\tfor ( event in methods ) {\n\t\t\t\tthis.off( event, methods[event], context );\n\t\t\t}\n\t\t} else {\n\t\t\t// Remove all connections to the context\n\t\t\tfor ( event in this.bindings ) {\n\t\t\t\tbindings = this.bindings[event];\n\t\t\t\ti = bindings.length;\n\t\t\t\twhile ( i-- ) {\n\t\t\t\t\t// bindings[i] may have been removed by the previous step's\n\t\t\t\t\t// this.off so check it still exists\n\t\t\t\t\tif ( bindings[i] && bindings[i].context === context ) {\n\t\t\t\t\t\tthis.off( event, bindings[i].method, context );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn this;\n\t};\n\n}() );\n\n/*global hasOwn */\n\n/**\n * @class OO.Registry\n * @mixins OO.EventEmitter\n *\n * @constructor\n */\noo.Registry = function OoRegistry() {\n\t// Mixin constructors\n\too.EventEmitter.call( this );\n\n\t// Properties\n\tthis.registry = {};\n};\n\n/* Inheritance */\n\noo.mixinClass( oo.Registry, oo.EventEmitter );\n\n/* Events */\n\n/**\n * @event register\n * @param {string} name\n * @param {Mixed} data\n */\n\n/**\n * @event unregister\n * @param {string} name\n * @param {Mixed} data Data removed from registry\n */\n\n/* Methods */\n\n/**\n * Associate one or more symbolic names with some data.\n *\n * Any existing entry with the same name will be overridden.\n *\n * @param {string|string[]} name Symbolic name or list of symbolic names\n * @param {Mixed} data Data to associate with symbolic name\n * @fires register\n * @throws {Error} Name argument must be a string or array\n */\noo.Registry.prototype.register = function ( name, data ) {\n\tvar i, len;\n\tif ( typeof name === 'string' ) {\n\t\tthis.registry[name] = data;\n\t\tthis.emit( 'register', name, data );\n\t} else if ( Array.isArray( name ) ) {\n\t\tfor ( i = 0, len = name.length; i < len; i++ ) {\n\t\t\tthis.register( name[i], data );\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Name must be a string or array, cannot be a ' + typeof name );\n\t}\n};\n\n/**\n * Remove one or more symbolic names from the registry\n *\n * @param {string|string[]} name Symbolic name or list of symbolic names\n * @fires unregister\n * @throws {Error} Name argument must be a string or array\n */\noo.Registry.prototype.unregister = function ( name ) {\n\tvar i, len, data;\n\tif ( typeof name === 'string' ) {\n\t\tdata = this.lookup( name );\n\t\tif ( data !== undefined ) {\n\t\t\tdelete this.registry[name];\n\t\t\tthis.emit( 'unregister', name, data );\n\t\t}\n\t} else if ( Array.isArray( name ) ) {\n\t\tfor ( i = 0, len = name.length; i < len; i++ ) {\n\t\t\tthis.unregister( name[i] );\n\t\t}\n\t} else {\n\t\tthrow new Error( 'Name must be a string or array, cannot be a ' + typeof name );\n\t}\n};\n\n/**\n * Get data for a given symbolic name.\n *\n * @param {string} name Symbolic name\n * @return {Mixed|undefined} Data associated with symbolic name\n */\noo.Registry.prototype.lookup = function ( name ) {\n\tif ( hasOwn.call( this.registry, name ) ) {\n\t\treturn this.registry[name];\n\t}\n};\n\n/*global createObject */\n\n/**\n * @class OO.Factory\n * @extends OO.Registry\n *\n * @constructor\n */\noo.Factory = function OoFactory() {\n\t// Parent constructor\n\too.Factory.parent.call( this );\n};\n\n/* Inheritance */\n\noo.inheritClass( oo.Factory, oo.Registry );\n\n/* Methods */\n\n/**\n * Register a constructor with the factory.\n *\n * Classes must have a static `name` property to be registered.\n *\n *     function MyClass() {};\n *     OO.initClass( MyClass );\n *     // Adds a static property to the class defining a symbolic name\n *     MyClass.static.name = 'mine';\n *     // Registers class with factory, available via symbolic name 'mine'\n *     factory.register( MyClass );\n *\n * @param {Function} constructor Constructor to use when creating object\n * @throws {Error} Name must be a string and must not be empty\n * @throws {Error} Constructor must be a function\n */\noo.Factory.prototype.register = function ( constructor ) {\n\tvar name;\n\n\tif ( typeof constructor !== 'function' ) {\n\t\tthrow new Error( 'constructor must be a function, cannot be a ' + typeof constructor );\n\t}\n\tname = constructor.static && constructor.static.name;\n\tif ( typeof name !== 'string' || name === '' ) {\n\t\tthrow new Error( 'Name must be a string and must not be empty' );\n\t}\n\n\t// Parent method\n\too.Factory.parent.prototype.register.call( this, name, constructor );\n};\n\n/**\n * Unregister a constructor from the factory.\n *\n * @param {Function} constructor Constructor to unregister\n * @throws {Error} Name must be a string and must not be empty\n * @throws {Error} Constructor must be a function\n */\noo.Factory.prototype.unregister = function ( constructor ) {\n\tvar name;\n\n\tif ( typeof constructor !== 'function' ) {\n\t\tthrow new Error( 'constructor must be a function, cannot be a ' + typeof constructor );\n\t}\n\tname = constructor.static && constructor.static.name;\n\tif ( typeof name !== 'string' || name === '' ) {\n\t\tthrow new Error( 'Name must be a string and must not be empty' );\n\t}\n\n\t// Parent method\n\too.Factory.parent.prototype.unregister.call( this, name );\n};\n\n/**\n * Create an object based on a name.\n *\n * Name is used to look up the constructor to use, while all additional arguments are passed to the\n * constructor directly, so leaving one out will pass an undefined to the constructor.\n *\n * @param {string} name Object name\n * @param {Mixed...} [args] Arguments to pass to the constructor\n * @return {Object} The new object\n * @throws {Error} Unknown object name\n */\noo.Factory.prototype.create = function ( name ) {\n\tvar obj, i,\n\t\targs = [],\n\t\tconstructor = this.lookup( name );\n\n\tif ( !constructor ) {\n\t\tthrow new Error( 'No class registered by that name: ' + name );\n\t}\n\n\t// Convert arguments to array and shift the first argument (name) off\n\tfor ( i = 1; i < arguments.length; i++ ) {\n\t\targs.push( arguments[i] );\n\t}\n\n\t// We can't use the \"new\" operator with .apply directly because apply needs a\n\t// context. So instead just do what \"new\" does: create an object that inherits from\n\t// the constructor's prototype (which also makes it an \"instanceof\" the constructor),\n\t// then invoke the constructor with the object as context, and return it (ignoring\n\t// the constructor's return value).\n\tobj = createObject( constructor.prototype );\n\tconstructor.apply( obj, args );\n\treturn obj;\n};\n\n/*jshint node:true */\nif ( typeof module !== 'undefined' && module.exports ) {\n\tmodule.exports = oo;\n} else {\n\tglobal.OO = oo;\n}\n\n}( this ) );\n"]}